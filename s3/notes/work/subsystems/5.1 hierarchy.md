5.1 # Hierarchy Migration — s3

Migrate s3 from global `S_Store` singleton to per-DB `Hierarchy` ownership, matching the ws design described in `5 hierarchy.md` and `11 database.md`.

---

## Problem

`S_Store` is a global singleton. Every consumer — DB_Firebase snapshots, DB_Test seed, Ancestry nav, UI components — writes to and reads from the same `store.*` Maps.

When the user switches from firebase to test:
1. `assign_to_store()` swaps all five Maps on the global store to point at test's Maps
2. Firebase `onSnapshot` listeners keep firing — but they write to `store.*`, which now points at test's Maps
3. Firebase's own data (on the `DB_Firebase` instance) stops receiving updates
4. Switching back restores stale firebase Maps; snapshot writes went to the wrong place

The spec in `11 database.md` (line 9) already says: "Each backend owns its own `Hierarchy` instance; switching databases swaps the active `Hierarchy`." The code diverged.

---

## Target

- Each `DB_Common` owns a `Hierarchy` instance (its runtime data)
- `Hierarchy` holds the five `$state` Maps + remember/forget/query methods
- Switching DBs swaps one pointer: `databases.db`
- Global access: `databases.db.hierarchy.things` (or shorthand `databases.hierarchy.things`)
- Firebase snapshots write to `this.hierarchy.*` — when FB is not active, writes go to its own Hierarchy silently
- `assign_to_store()` goes away
- `store.svelte.ts` goes away

---

## Hierarchy class

Rename `S_Store` → `Hierarchy`. File: `Hierarchy.svelte.ts` (needs `$state` runes).

Keeps everything currently on `S_Store`:
- `things`, `relationships`, `predicates`, `traits`, `tags` — all `$state(new Map<>())`
- `remember_thing`, `forget_thing`, `remember_relationship`, etc.
- `children_of`, `parents_of`
- `forget_all`

No new methods in this migration. Future phases grow the class (indexes, ancestry tracking, orchestrated mutations).

---

## Files changed

| File | What changes |
|---|---|
| `store/store.svelte.ts` | **Delete.** |
| `store/store.test.ts` | Instantiate `new Hierarchy()` per test instead of importing singleton. Move to `hierarchy/`. |
| `hierarchy/Hierarchy.svelte.ts` | **New.** Renamed from `S_Store`. Class export only, no singleton. |
| `db/DB_Common.ts` | Add `hierarchy = new Hierarchy()`. Drop the five duplicate plain Maps. Drop `assign_to_store()`. `persist_all()` reads from `this.hierarchy.*`. |
| `db/DB_Firebase.ts` | All `store.*` → `this.hierarchy.*` (~40 refs). Snapshot handlers, CRUD methods, fetch methods. |
| `db/DB_Test.ts` | `store.*` → `this.hierarchy.*` |
| `db/Databases.svelte.ts` | Add `get hierarchy() { return this.db.hierarchy; }`. `change_database` drops `assign_to_store()` call — just swaps `this.db` + `becomeFocus`. |
| `nav/Ancestry.ts` | `store.*` → `databases.hierarchy.*` (lines 52, 59, 90) |
| `svelte/details/D_Data.svelte` | `store.*` → `databases.hierarchy.*` |
| `signals/Events.svelte.ts` | Check for `store` refs, update if any |

---

## Reactivity chain

```
databases.db          ($state on Databases)
  └─ .hierarchy       (plain field on DB_Common — but accessed through $state proxy)
       └─ .things     ($state Map on Hierarchy)
            └─ .set() (tracked by Svelte 5 deep reactivity)
```

- DB switch: `databases.db = newDb` → every component reading `databases.hierarchy.*` re-renders
- Entity mutation: `this.hierarchy.things.set(id, thing)` → reactive if accessed through the `$state` chain
- Firebase while inactive: `this.hierarchy.things.set(...)` mutates FB's own Hierarchy. No component reads it. No wasted renders, no corruption.

---

## Migration order

1. Create `hierarchy/Hierarchy.svelte.ts` — copy `S_Store` class, rename to `Hierarchy`, remove singleton export
2. `DB_Common`: add `hierarchy = new Hierarchy()`, drop duplicate Maps and `assign_to_store()`
3. `Databases.svelte.ts`: add `get hierarchy()` getter, simplify `change_database`
4. `DB_Firebase.ts`: bulk rename `store.` → `this.hierarchy.`
5. `DB_Test.ts`: same rename
6. `Ancestry.ts`, `D_Data.svelte`, other consumers: `store.` → `databases.hierarchy.`
7. Delete `store/store.svelte.ts`
8. Move and update `store.test.ts` → `hierarchy/Hierarchy.test.ts`
9. Verify: `yarn svelte-check`, `yarn vitest`

---

## What this does NOT change

- No new indexing (ancestry dicts, HID lookups) — that's future work
- No mutation orchestration (create child, delete cascading) — that's future work
- No changes to entity classes
- No changes to UI components beyond import paths
- `DB_Common`'s persist methods stay as-is — they just read from `this.hierarchy.*` instead of global `store.*`

---

## Risk

Low. Mechanical rename + pointer restructure. No logic changes. The five Maps, the remember/forget methods, and the derived queries all transfer unchanged. The only behavioral difference: Firebase snapshots write to the correct Maps regardless of which DB is active.
