import type { Projected, O_Scene, Dimension_Rect, Label_Rect, Angle_Rect } from '../types/Interfaces';
import type Smart_Object from '../runtime/Smart_Object';
import type { Axis } from '../runtime/Smart_Object';
import { face_label } from '../editors/Face_Label';
import { T_Hit_3D } from '../types/Enumerations';
import { units, Units } from '../types/Units';
import { hits_3d } from '../managers/Hits_3D';
import { mat4, vec3, vec4 } from 'gl-matrix';
import { Size } from '../types/Coordinates';
import { stores } from '../managers/Stores';
import { colors } from '../draw/Colors';
import { debug } from '../common/Debug';
import { drag } from '../editors/Drag';
import { get } from 'svelte/store';
import { camera } from './Camera';
import { scene } from './Scene';
import Flatbush from 'flatbush';

class Render {
  private occluding_index: Flatbush | null = null;  /** Spatial index for screen-space face bounding boxes (rebuilt each frame). */
  private ctx!: CanvasRenderingContext2D;
  private mvp_matrix = mat4.create();
  private canvas!: HTMLCanvasElement;
  private size: Size = Size.zero;
  private dpr = 1;

  /** Per-frame dimension rects for click-to-edit. Cleared each render(). */
  dimension_rects: Dimension_Rect[] = [];

  /** Per-frame face name rects for click-to-edit. Cleared each render(). */
  face_name_rects: Label_Rect[] = [];
  angular_rects: Angle_Rect[] = [];

  /** Per-frame intersection segments between parent-child SOs. Collected by render_intersections, consumed by render_angulars. */
  private intersection_segments: {
    start: vec3; end: vec3;
    parent_scene: O_Scene; child_scene: O_Scene;
    parent_face_idx: number; child_face_idx: number;
    parent_face_corners: vec3[];
  }[] = [];

  /** Per-frame list of front-facing faces for occlusion: world-space normal, offset, and screen-space polygon. */
  private occluding_faces: {
    n: vec3; d: number;            // face plane in world space (n·p = d)
    corners: vec3[];               // world-space corners
    poly: { x: number; y: number }[]; // screen-space polygon
    obj_id: string;
  }[] = [];

  /** Logical (CSS) size — for external consumers like camera init. */
  get logical_size(): Size { return this.size; }

  init(canvas: HTMLCanvasElement): void {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d')!;
    this.dpr = window.devicePixelRatio || 1;
    const w = canvas.width, h = canvas.height;
    this.size = new Size(w, h);
    this.apply_dpr(w, h);
  }

  resize(width: number, height: number): void {
    this.dpr = window.devicePixelRatio || 1;
    this.size = new Size(width, height);
    this.apply_dpr(width, height);
    camera.resize(this.size);
  }

  /** Set canvas buffer to physical pixels, CSS size to logical pixels. */
  private apply_dpr(w: number, h: number): void {
    this.canvas.width = w * this.dpr;
    this.canvas.height = h * this.dpr;
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    this.ctx.scale(this.dpr, this.dpr);
  }

  render(): void {
    this.ctx.clearRect(0, 0, this.size.width, this.size.height);
    this.dimension_rects = [];
    this.face_name_rects = [];
    this.angular_rects = [];

    const objects = scene.get_all();
    const is_2d = stores.current_view_mode() === '2d';
    const solid = stores.is_solid();

    if (is_2d) this.render_grid(objects);

    // Phase 1: project all vertices and update hit-test caches
    const projected_map = new Map<string, Projected[]>();
    for (const obj of objects) {
      const world_matrix = this.get_world_matrix(obj);
      const projected = obj.so.vertices.map((v) => this.project_vertex(v, world_matrix));
      projected_map.set(obj.id, projected);
      hits_3d.update_projected(obj.id, projected, world_matrix);
    }

    // Phase 2: fill front-facing faces (occlusion layer)
    // In solid or 2D mode, fill with white so rear edges are hidden.
    // Sort all front-facing faces back-to-front by average depth.
    if (is_2d || solid) {
      const face_draws: { face: number[]; projected: Projected[]; z_avg: number; fi: number }[] = [];
      for (const obj of objects) {
        const projected = projected_map.get(obj.id)!;
        if (!obj.faces) continue;
        for (let fi = 0; fi < obj.faces.length; fi++) {
          const face = obj.faces[fi];
          if (this.face_winding(face, projected) >= 0) continue; // skip back-facing
          let z_sum = 0;
          for (const vi of face) z_sum += projected[vi].z;
          face_draws.push({ face, projected, z_avg: z_sum / face.length, fi });
        }
      }
      // Back-to-front: largest z (farthest) first
      face_draws.sort((a, b) => b.z_avg - a.z_avg);
      for (const { face, projected } of face_draws) {
        this.fill_face(face, projected, '#fff');
      }
    }

    // Phase 2b: debug face fills (non-solid mode)
    if (!is_2d && !solid) {
      for (const obj of objects) {
        const projected = projected_map.get(obj.id)!;
        if (!obj.faces) continue;
        // Back-facing first, then front-facing on top
        for (let fi = 0; fi < obj.faces.length; fi++) {
          if (this.face_winding(obj.faces[fi], projected) < 0) continue;
          this.draw_debug_face(obj.faces[fi], fi, projected);
        }
        for (let fi = 0; fi < obj.faces.length; fi++) {
          if (this.face_winding(obj.faces[fi], projected) >= 0) continue;
          this.draw_debug_face(obj.faces[fi], fi, projected);
        }
      }
    }

    // Build occluding face list for edge clipping (solid or 2D mode)
    this.occluding_faces = [];
    if (is_2d || solid) {
      for (const obj of objects) {
        const projected = projected_map.get(obj.id)!;
        if (!obj.faces) continue;
        const world = this.get_world_matrix(obj);
        const verts = obj.so.vertices;
        for (const face of obj.faces) {
          if (this.face_winding(face, projected) >= 0) continue;
          // Screen-space polygon
          const poly: { x: number; y: number }[] = [];
          let cam_behind = false;
          for (const vi of face) {
            if (projected[vi].w < 0) { cam_behind = true; break; }
            poly.push({ x: projected[vi].x, y: projected[vi].y });
          }
          if (cam_behind) continue;
          // World-space corners and plane
          const corners: vec3[] = [];
          for (const vi of face) {
            const lv = verts[vi];
            const wv = vec4.create();
            vec4.transformMat4(wv, [lv[0], lv[1], lv[2], 1], world);
            corners.push(vec3.fromValues(wv[0], wv[1], wv[2]));
          }
          const e1 = vec3.sub(vec3.create(), corners[1], corners[0]);
          const e2 = vec3.sub(vec3.create(), corners[3], corners[0]);
          const n = vec3.cross(vec3.create(), e1, e2);
          vec3.normalize(n, n);
          const d = vec3.dot(n, corners[0]);
          this.occluding_faces.push({ n, d, corners, poly, obj_id: obj.id });
        }
      }
      // Build spatial index from screen-space face bounding boxes
      if (this.occluding_faces.length > 0) {
        const index = new Flatbush(this.occluding_faces.length);
        for (const face of this.occluding_faces) {
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const p of face.poly) {
            if (p.x < minX) minX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.x > maxX) maxX = p.x;
            if (p.y > maxY) maxY = p.y;
          }
          index.add(minX, minY, maxX, maxY);
        }
        index.finish();
        this.occluding_index = index;
      } else {
        this.occluding_index = null;
      }
    }

    // Phase 2c: intersection lines between overlapping SOs
    if (objects.length > 1) {
      this.render_intersections(objects);
    }

    // Phase 3: draw edges
    for (const obj of objects) {
      const projected = projected_map.get(obj.id)!;
      const world = (is_2d || solid) ? this.get_world_matrix(obj) : undefined;
      this.render_edges(obj, projected, is_2d, solid, world);
      this.render_face_names(obj, projected, world);
    }

    this.render_selection();
    if (stores.show_dimensionals()) this.render_dimensions();
    if (stores.show_angulars()) this.render_angulars();
    this.render_hover();
    if (debug.enabled) this.render_front_face_label();
  }

  // ═══════════════════════════════════════════════════════════════════
  // 2D GRID
  // ═══════════════════════════════════════════════════════════════════

  private render_grid(objects: O_Scene[]): void {
    const root_so = get(stores.w_root_so);
    if (!root_so) return;

    const front_face = hits_3d.front_most_face(root_so);
    if (front_face < 0) return;

    const [axis_a, axis_b] = root_so.face_axes(front_face);
    const fixed_axis = root_so.face_fixed_axis(front_face);

    // Find root SO's scene for world matrix
    const root_scene = objects.find(o => o.so === root_so);
    if (!root_scene) return;
    const world = this.get_world_matrix(root_scene);

    // Grid spacing in mm — start from precision, double until lines are ≥ min_px apart
    const system = Units.current_unit_system();
    const precision = stores.current_precision();
    const max_dim = Math.max(root_so.width, root_so.height, root_so.depth);
    const base_spacing = units.grid_spacing_mm(system, precision, max_dim);
    if (base_spacing <= 0) return;

    // Measure screen-space gap: project two adjacent points along axis_a
    const a_ref = axis_a === 'x' ? root_so.x_min : axis_a === 'y' ? root_so.y_min : root_so.z_min;
    const ref_point = (offset: number): vec3 => {
      const p = vec3.create();
      const set = (ax: Axis, v: number) => { if (ax === 'x') p[0] = v; else if (ax === 'y') p[1] = v; else p[2] = v; };
      set(axis_a, a_ref + offset);
      set(axis_b, axis_b === 'x' ? root_so.x_min : axis_b === 'y' ? root_so.y_min : root_so.z_min);
      set(fixed_axis, fixed_axis === 'x' ? (root_so.x_min + root_so.x_max) / 2
        : fixed_axis === 'y' ? (root_so.y_min + root_so.y_max) / 2
        : (root_so.z_min + root_so.z_max) / 2);
      return p;
    };
    const p0 = this.project_vertex(ref_point(0), world);
    const p1 = this.project_vertex(ref_point(base_spacing), world);
    const px_per_cell = Math.hypot(p1.x - p0.x, p1.y - p0.y);

    const min_px = 8; // minimum pixels between grid lines
    let spacing = base_spacing;
    if (px_per_cell > 0) {
      while (spacing * (px_per_cell / base_spacing) < min_px) spacing *= 2;
    }

    // Axis bounds — extend enough to fill the canvas
    const canvas_diag_mm = px_per_cell > 0
      ? Math.hypot(this.ctx.canvas.width, this.ctx.canvas.height) / (px_per_cell / base_spacing)
      : max_dim * 50;
    const bounds = (axis: Axis): [number, number] => {
      const min = axis === 'x' ? root_so.x_min : axis === 'y' ? root_so.y_min : root_so.z_min;
      const max = axis === 'x' ? root_so.x_max : axis === 'y' ? root_so.y_max : root_so.z_max;
      const mid = (min + max) / 2;
      return [mid - canvas_diag_mm, mid + canvas_diag_mm];
    };

    // Fixed axis value (the plane of the front face)
    const fixed_val = fixed_axis === 'x'
      ? (root_so.x_min + root_so.x_max) / 2
      : fixed_axis === 'y'
        ? (root_so.y_min + root_so.y_max) / 2
        : (root_so.z_min + root_so.z_max) / 2;

    const [a_min, a_max] = bounds(axis_a);
    const [b_min, b_max] = bounds(axis_b);

    // Snap grid origin to SO edge alignment
    const a_origin = axis_a === 'x' ? root_so.x_min : axis_a === 'y' ? root_so.y_min : root_so.z_min;
    const b_origin = axis_b === 'x' ? root_so.x_min : axis_b === 'y' ? root_so.y_min : root_so.z_min;

    const ctx = this.ctx;
    ctx.save();
    ctx.strokeStyle = get(colors.w_accent_color);
    ctx.lineWidth = stores.line_thickness();
    ctx.lineCap = 'round';
    ctx.setLineDash([1, 4]);

    const make_point = (a_val: number, b_val: number): vec3 => {
      const p = vec3.create();
      const set = (axis: Axis, val: number) => {
        if (axis === 'x') p[0] = val;
        else if (axis === 'y') p[1] = val;
        else p[2] = val;
      };
      set(axis_a, a_val);
      set(axis_b, b_val);
      set(fixed_axis, fixed_val);
      return p;
    };

    // Lines along axis_a (sweep axis_b)
    const a_start = a_origin - Math.ceil((a_origin - a_min) / spacing) * spacing;
    for (let a = a_start; a <= a_max; a += spacing) {
      const p1 = this.project_vertex(make_point(a, b_min), world);
      const p2 = this.project_vertex(make_point(a, b_max), world);
      if (p1.w < 0 || p2.w < 0) continue;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    // Lines along axis_b (sweep axis_a)
    const b_start = b_origin - Math.ceil((b_origin - b_min) / spacing) * spacing;
    for (let b = b_start; b <= b_max; b += spacing) {
      const p1 = this.project_vertex(make_point(a_min, b), world);
      const p2 = this.project_vertex(make_point(a_max, b), world);
      if (p1.w < 0 || p2.w < 0) continue;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    ctx.setLineDash([]);
    ctx.restore();
  }

  private get_world_matrix(obj: O_Scene): mat4 {
    const so = obj.so;
    const center: vec3 = [
      (so.x_min + so.x_max) / 2,
      (so.y_min + so.y_max) / 2,
      (so.z_min + so.z_max) / 2,
    ];
    const orientation = so.orientation;
    const scale_vec = [obj.scale, obj.scale, obj.scale] as [number, number, number];

    // Rotate around the SO's exact 3D center: translate to center, rotate, translate back
    const local = mat4.create();
    mat4.fromTranslation(local, [-center[0], -center[1], -center[2]]);
    const rot = mat4.create();
    mat4.fromQuat(rot, orientation);
    mat4.multiply(local, rot, local);
    const from_center = mat4.create();
    mat4.fromTranslation(from_center, center);
    mat4.multiply(local, from_center, local);

    // Apply scale and position
    const scale_mat = mat4.create();
    mat4.fromScaling(scale_mat, scale_vec);
    mat4.multiply(local, scale_mat, local);
    const pos_mat = mat4.create();
    mat4.fromTranslation(pos_mat, obj.position);
    mat4.multiply(local, pos_mat, local);

    if (obj.parent) {
      const parent_world = this.get_world_matrix(obj.parent);
      mat4.multiply(local, parent_world, local);
    }

    return local;
  }

  private project_vertex(v: vec3, world_matrix: mat4): Projected {
    const point = vec4.fromValues(v[0], v[1], v[2], 1);

    mat4.multiply(this.mvp_matrix, camera.view, world_matrix);
    mat4.multiply(this.mvp_matrix, camera.projection, this.mvp_matrix);

    vec4.transformMat4(point, point, this.mvp_matrix);
    const w = point[3];
    return {
      x: (point[0] / w + 1) * 0.5 * this.size.width,
      y: (1 - point[1] / w) * 0.5 * this.size.height,
      z: point[2] / w,
      w,
    };
  }

  // Debug face colors: primary + secondary at 50% saturation
  // Face indices: 0=front(z_min), 1=back(z_max), 2=left(x_min), 3=right(x_max), 4=top(y_max), 5=bottom(y_min)
  private readonly FACE_RGB = [
    [191, 64, 64],    // 0: front - red (50% sat)
    [64, 191, 64],    // 1: back - green
    [64, 64, 191],    // 2: left - blue
    [191, 191, 64],   // 3: right - yellow
    [64, 191, 191],   // 4: top - cyan
    [191, 64, 191],   // 5: bottom - magenta
  ];

  private fill_face(face: number[], projected: Projected[], color: string): void {
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
    for (let i = 1; i < face.length; i++) {
      this.ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
    }
    this.ctx.closePath();
    this.ctx.fill();
  }

  private render_edges(obj: O_Scene, projected: Projected[], is_2d: boolean, solid: boolean, world?: mat4): void {
    const ctx = this.ctx;
    ctx.lineWidth = stores.line_thickness();
    ctx.lineCap = 'square';

    // In 2D or solid mode, only draw edges belonging to front-facing faces
    const front_edges = (is_2d || solid) ? this.front_face_edges(obj, projected) : null;

    // During face drag, highlight the guidance face's edges on the parent SO
    const guide = drag.guidance_face;
    const guidance_edges = (guide && guide.scene === obj) ? this.face_edge_keys(obj, guide.face_index) : null;

    if ((is_2d || solid) && world) {
      // Solid / 2D mode: per-edge occlusion clipping, batch clipped segments by color
      const normal_path = new Path2D();
      const guide_path = new Path2D();

      for (const [i, j] of obj.edges) {
        const a = projected[i], b = projected[j];
        if (a.w < 0 || b.w < 0) continue;
        if (front_edges && !front_edges.has(`${Math.min(i, j)}-${Math.max(i, j)}`)) continue;

        const vi = obj.so.vertices[i], vj = obj.so.vertices[j];
        const wi = vec4.create(), wj = vec4.create();
        vec4.transformMat4(wi, [vi[0], vi[1], vi[2], 1], world);
        vec4.transformMat4(wj, [vj[0], vj[1], vj[2], 1], world);

        const visible = this.clip_segment_for_occlusion(
          { x: a.x, y: a.y }, { x: b.x, y: b.y },
          vec3.fromValues(wi[0], wi[1], wi[2]), vec3.fromValues(wj[0], wj[1], wj[2]), obj.id
        );

        const edge_key = `${Math.min(i, j)}-${Math.max(i, j)}`;
        const path = guidance_edges?.has(edge_key) ? guide_path : normal_path;
        for (const [s, e] of visible) {
          path.moveTo(Math.round(s.x) + 0.5, Math.round(s.y) + 0.5);
          path.lineTo(Math.round(e.x) + 0.5, Math.round(e.y) + 0.5);
        }
      }

      ctx.strokeStyle = `${obj.color}1)`;
      ctx.stroke(normal_path);
      if (guidance_edges) {
        ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
        ctx.stroke(guide_path);
      }
    } else {
      // Non-solid: batch edges by color into single beginPath/stroke calls
      const normal_path = new Path2D();
      const guide_path = new Path2D();

      for (const [i, j] of obj.edges) {
        const a = projected[i], b = projected[j];
        if (a.w < 0 || b.w < 0) continue;
        if (front_edges && !front_edges.has(`${Math.min(i, j)}-${Math.max(i, j)}`)) continue;

        const ax = Math.round(a.x) + 0.5, ay = Math.round(a.y) + 0.5;
        const bx = Math.round(b.x) + 0.5, by = Math.round(b.y) + 0.5;

        const edge_key = `${Math.min(i, j)}-${Math.max(i, j)}`;
        const path = guidance_edges?.has(edge_key) ? guide_path : normal_path;
        path.moveTo(ax, ay);
        path.lineTo(bx, by);
      }

      ctx.strokeStyle = `${obj.color}1)`;
      ctx.stroke(normal_path);

      if (guidance_edges) {
        ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
        ctx.stroke(guide_path);
      }
    }
  }

  /**
   * Draw intersection lines between overlapping SOs (general case).
   * For each pair of faces (one from each SO), compute the plane-plane
   * intersection line, then clip it to both face quads.
   */
  private render_intersections(objects: O_Scene[]): void {
    const ctx = this.ctx;
    ctx.lineWidth = stores.line_thickness();

    // Build world-space face data for each object: normal, offset, 4 corner positions
    type WFace = { n: vec3; d: number; corners: vec3[]; fi: number; obj: O_Scene };
    const obj_faces: WFace[][] = [];

    for (const obj of objects) {
      const world = this.get_world_matrix(obj);

      const faces: WFace[] = [];
      const verts = obj.so.vertices; // local space
      const face_indices = obj.faces;
      if (!face_indices) { obj_faces.push([]); continue; }

      for (let fi = 0; fi < face_indices.length; fi++) {
        // Transform face corners to world space
        const corners: vec3[] = [];
        for (const vi of face_indices[fi]) {
          const lv = verts[vi];
          const wv = vec4.create();
          vec4.transformMat4(wv, [lv[0], lv[1], lv[2], 1], world);
          corners.push(vec3.fromValues(wv[0], wv[1], wv[2]));
        }

        // Derive normal from world-space corners (accounts for all transforms)
        const e1 = vec3.sub(vec3.create(), corners[1], corners[0]);
        const e2 = vec3.sub(vec3.create(), corners[3], corners[0]);
        const n = vec3.cross(vec3.create(), e1, e2);
        vec3.normalize(n, n);

        // Plane offset: d = n · p (any corner)
        const d = vec3.dot(n, corners[0]);
        faces.push({ n, d, corners, fi, obj });
      }
      obj_faces.push(faces);
    }

    this.intersection_segments = [];

    for (let i = 0; i < objects.length; i++) {
      for (let j = i + 1; j < objects.length; j++) {
        // Determine parent/child relationship (if any)
        const i_is_parent_of_j = objects[j].parent === objects[i];
        const j_is_parent_of_i = objects[i].parent === objects[j];

        for (let fi_a = 0; fi_a < obj_faces[i].length; fi_a++) {
          for (let fi_b = 0; fi_b < obj_faces[j].length; fi_b++) {
            const fA = obj_faces[i][fi_a];
            const fB = obj_faces[j][fi_b];
            const seg = this.intersect_face_pair(ctx, fA, fB, objects[j].color);

            // Collect segment for angulars if parent-child pair
            if (seg && (i_is_parent_of_j || j_is_parent_of_i)) {
              const parent_scene = i_is_parent_of_j ? objects[i] : objects[j];
              const child_scene = i_is_parent_of_j ? objects[j] : objects[i];
              const parent_face = i_is_parent_of_j ? fA : fB;
              const child_face = i_is_parent_of_j ? fB : fA;
              this.intersection_segments.push({
                start: seg.start, end: seg.end,
                parent_scene, child_scene,
                parent_face_idx: parent_face.fi,
                child_face_idx: child_face.fi,
                parent_face_corners: parent_face.corners,
              });
            }
          }
        }
      }
    }
  }

  /**
   * Given two face planes in world space, compute their intersection line
   * and clip it to both face quads. Draw the resulting segment if any.
   */
  private intersect_face_pair(
    ctx: CanvasRenderingContext2D,
    fA: { n: vec3; d: number; corners: vec3[] },
    fB: { n: vec3; d: number; corners: vec3[] },
    color: string,
  ): { start: vec3; end: vec3 } | null {
    const eps = 1e-8;

    // Line direction = cross(nA, nB)
    const dir = vec3.create();
    vec3.cross(dir, fA.n, fB.n);
    const dir_len = vec3.length(dir);
    if (dir_len < eps) return null; // parallel planes
    vec3.scale(dir, dir, 1 / dir_len);

    // Find a point on the intersection line by solving
    // nA·p = dA, nB·p = dB as a 2×2 system.
    // Set the coordinate along dir's largest component to 0.
    const nA = fA.n, nB = fB.n, dA = fA.d, dB = fB.d;

    const abs_dir = [Math.abs(dir[0]), Math.abs(dir[1]), Math.abs(dir[2])];
    const max_axis = abs_dir[0] >= abs_dir[1] && abs_dir[0] >= abs_dir[2] ? 0
                   : abs_dir[1] >= abs_dir[2] ? 1 : 2;
    const a1 = (max_axis + 1) % 3, a2 = (max_axis + 2) % 3;

    const det = nA[a1] * nB[a2] - nA[a2] * nB[a1];
    if (Math.abs(det) < eps) return null;

    const p0 = vec3.create();
    p0[a1] = (dA * nB[a2] - dB * nA[a2]) / det;
    p0[a2] = (nA[a1] * dB - nB[a1] * dA) / det;
    p0[max_axis] = 0;

    // Clip the infinite line (p0 + t*dir) to both face quads
    const result_a = this.clip_to_quad(p0, dir, fA.corners, fA.n, -1e6, 1e6);
    if (!result_a) return null;

    const result = this.clip_to_quad(p0, dir, fB.corners, fB.n, result_a[0], result_a[1]);
    if (!result) return null;

    const [tA, tB] = result;
    if (tA >= tB - eps) return null;

    const start = vec3.scaleAndAdd(vec3.create(), p0, dir, tA);
    const end = vec3.scaleAndAdd(vec3.create(), p0, dir, tB);

    const identity = mat4.create();
    const s1 = this.project_vertex(start, identity);
    const s2 = this.project_vertex(end, identity);
    if (s1.w < 0 || s2.w < 0) return null;

    ctx.strokeStyle = `${color}1)`;

    // Intersection lines: skip the two coplanar generating faces, not all faces from both objects
    const visible = this.clip_segment_for_occlusion(
      { x: s1.x, y: s1.y }, { x: s2.x, y: s2.y }, start, end, '', [fA, fB]
    );
    for (const [a, b] of visible) {
      ctx.beginPath();
      ctx.moveTo(Math.round(a.x) + 0.5, Math.round(a.y) + 0.5);
      ctx.lineTo(Math.round(b.x) + 0.5, Math.round(b.y) + 0.5);
      ctx.stroke();
    }

    return { start, end };
  }

  /**
   * Clip a segment against all occluding faces from other SOs.
   * Uses world-space face normals to determine which side of the face plane
   * each portion of the edge is on. The portion behind the face (and inside
   * the face's screen polygon) gets hidden.
   *
   * w1, w2: world-space endpoints of the edge segment.
   */
  private clip_segment_for_occlusion(
    p1: { x: number; y: number },
    p2: { x: number; y: number },
    w1: vec3,
    w2: vec3,
    skip_ids: string | string[],
    skip_planes?: { n: vec3; d: number }[],
  ): [{ x: number; y: number }, { x: number; y: number }][] {
    // Work entirely in screen space. World space is only used for front/behind test.
    let intervals: [number, number][] = [[0, 1]]; // screen-space t along p1→p2
    const skip = Array.isArray(skip_ids) ? skip_ids : [skip_ids];
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const identity = mat4.create();

    // Query spatial index for faces whose screen-space bounding boxes overlap this edge
    const edge_min_x = Math.min(p1.x, p2.x), edge_min_y = Math.min(p1.y, p2.y);
    const edge_max_x = Math.max(p1.x, p2.x), edge_max_y = Math.max(p1.y, p2.y);
    const candidates = this.occluding_index
      ? this.occluding_index.search(edge_min_x, edge_min_y, edge_max_x, edge_max_y)
      : this.occluding_faces.map((_, i) => i);

    for (const fi of candidates) {
      const face = this.occluding_faces[fi];
      if (!face) continue;
      if (skip.includes(face.obj_id)) continue;
      if (skip_planes && skip_planes.some(sp => {
        const dot = vec3.dot(sp.n, face.n);
        return (Math.abs(dot - 1) < 1e-6 && Math.abs(sp.d - face.d) < 1e-6) ||
               (Math.abs(dot + 1) < 1e-6 && Math.abs(sp.d + face.d) < 1e-6);
      })) continue;

      // Signed distances from edge endpoints to face plane (world space)
      const d1 = vec3.dot(face.n, w1) - face.d;
      const d2 = vec3.dot(face.n, w2) - face.d;

      if (d1 > 0 && d2 > 0) continue;

      // Find screen-space t where the segment crosses the face plane
      // by projecting the world-space crossing point to screen
      let s_behind_start = 0, s_behind_end = 1;
      if (d1 > 0 && d2 <= 0) {
        const t_cross = d1 / (d1 - d2);
        const wc = vec3.lerp(vec3.create(), w1, w2, t_cross);
        const pc = this.project_vertex(wc, identity);
        // Find screen t of the crossing point along p1→p2
        const cdx = pc.x - p1.x, cdy = pc.y - p1.y;
        s_behind_start = Math.abs(dx) > Math.abs(dy) ? cdx / dx : cdy / dy;
        s_behind_end = 1;
      } else if (d1 <= 0 && d2 > 0) {
        const t_cross = d1 / (d1 - d2);
        const wc = vec3.lerp(vec3.create(), w1, w2, t_cross);
        const pc = this.project_vertex(wc, identity);
        const cdx = pc.x - p1.x, cdy = pc.y - p1.y;
        s_behind_start = 0;
        s_behind_end = Math.abs(dx) > Math.abs(dy) ? cdx / dx : cdy / dy;
      }
      // else both behind: s_behind_start=0, s_behind_end=1

      // Clip the "behind" portion to the face's screen-space polygon
      const bs = { x: p1.x + dx * s_behind_start, y: p1.y + dy * s_behind_start };
      const be = { x: p1.x + dx * s_behind_end, y: p1.y + dy * s_behind_end };

      const clip = this.clip_segment_to_polygon_2d(bs, be, face.poly);
      if (!clip) continue;

      // Map clip t values back to the full screen-space [0,1] range
      const s_range = s_behind_end - s_behind_start;
      const s_enter = s_behind_start + clip[0] * s_range;
      const s_leave = s_behind_start + clip[1] * s_range;

      // Remove the occluded interval
      const new_intervals: [number, number][] = [];
      for (const [a, b] of intervals) {
        if (s_leave <= a || s_enter >= b) {
          new_intervals.push([a, b]);
          continue;
        }
        if (s_enter > a) new_intervals.push([a, s_enter]);
        if (s_leave < b) new_intervals.push([s_leave, b]);
      }
      intervals = new_intervals;
      if (intervals.length === 0) break;
    }

    return intervals.map(([a, b]) => [
      { x: p1.x + dx * a, y: p1.y + dy * a },
      { x: p1.x + dx * b, y: p1.y + dy * b },
    ]);
  }

  /**
   * 2D Cyrus-Beck: clip a segment (p1→p2, t in [0,1]) to a convex polygon.
   * Returns [t_enter, t_leave] or null if fully outside.
   */
  private clip_segment_to_polygon_2d(
    p1: { x: number; y: number },
    p2: { x: number; y: number },
    poly: { x: number; y: number }[],
  ): [number, number] | null {
    let t_enter = 0, t_leave = 1;
    const dx = p2.x - p1.x, dy = p2.y - p1.y;

    for (let i = 0; i < poly.length; i++) {
      const c0 = poly[i];
      const c1 = poly[(i + 1) % poly.length];

      // Inward-pointing normal for this edge (CW winding in screen space, Y-down)
      const ex = c1.x - c0.x, ey = c1.y - c0.y;
      const nx = ey, ny = -ex; // rotate edge 90 degrees right = inward for CW

      const denom = nx * dx + ny * dy;
      const num = nx * (p1.x - c0.x) + ny * (p1.y - c0.y);

      if (Math.abs(denom) < 1e-10) {
        // Segment parallel to edge — if outside, reject
        if (num < 0) return null;
        continue;
      }

      const t = -num / denom;
      if (denom > 0) {
        // Entering the half-plane
        if (t > t_enter) t_enter = t;
      } else {
        // Leaving the half-plane
        if (t < t_leave) t_leave = t;
      }

      if (t_enter > t_leave) return null;
    }

    if (t_enter >= t_leave) return null;
    return [t_enter, t_leave];
  }

  /**
   * Clip parameterized line (p0 + t*dir) to the interior of a convex quad.
   * Returns [t_min, t_max] or null if fully clipped away.
   * Uses Cyrus-Beck clipping against each edge of the quad.
   */
  private clip_to_quad(
    p0: vec3, dir: vec3,
    corners: vec3[], face_normal: vec3,
    t_min: number, t_max: number
  ): [number, number] | null {
    const n_edges = corners.length;
    for (let i = 0; i < n_edges; i++) {
      const c0 = corners[i];
      const c1 = corners[(i + 1) % n_edges];

      // Edge vector
      const edge = vec3.sub(vec3.create(), c1, c0);

      // Inward normal of this edge (cross of face normal with edge, pointing inward)
      const inward = vec3.cross(vec3.create(), face_normal, edge);

      // For the line p0 + t*dir, compute:
      //   dot(inward, p0 + t*dir - c0) >= 0  means "inside this edge"
      //   dot(inward, p0 - c0) + t * dot(inward, dir) >= 0
      const diff = vec3.sub(vec3.create(), p0, c0);
      const numer = vec3.dot(inward, diff);
      const alignment = vec3.dot(inward, dir);

      if (Math.abs(alignment) < 1e-12) {
        // Line parallel to edge — check which side
        if (numer < 0) return null; // outside
        continue;
      }

      const t = -numer / alignment;
      if (alignment > 0) {
        // Entering: line moves into inside half-plane
        if (t > t_min) t_min = t;
      } else {
        // Leaving: line moves out of inside half-plane
        if (t < t_max) t_max = t;
      }

      if (t_min > t_max) return null;
    }

    return [t_min, t_max];
  }

  private render_face_names(obj: O_Scene, projected: Projected[], world?: mat4): void {
    if (!obj.faces) return;
    const ctx = this.ctx;
    ctx.font = '10px sans-serif';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const verts = obj.so.vertices;

    for (let fi = 0; fi < obj.faces.length; fi++) {
      const face = obj.faces[fi];
      const winding = this.face_winding(face, projected);
      if (winding >= 0 || Math.abs(winding) < 2000) continue; // skip back-facing and edge-on

      // Compute centroid of face in screen space
      let cx = 0, cy = 0, cz = 0, behind = false;
      for (const vi of face) {
        if (projected[vi].w < 0) { behind = true; break; }
        cx += projected[vi].x;
        cy += projected[vi].y;
        cz += projected[vi].z;
      }
      if (behind) continue;
      cx /= face.length;
      cy /= face.length;
      cz /= face.length;

      // Occlusion: skip label if another SO's face is in front at this screen point
      if (world && this.is_point_occluded(cx, cy, face, verts, world, obj.id)) continue;

      const text = debug.enabled ? `${obj.so.name} ${fi}` : obj.so.name;
      const tw = ctx.measureText(text).width;
      const fls = face_label.state;
      if (!fls || fls.so !== obj.so || fls.face_index !== fi) {
        ctx.fillStyle = 'white';
        ctx.fillRect(Math.round(cx) - tw / 2 - 2, Math.round(cy) - 6, tw + 4, 12);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillText(text, Math.round(cx), Math.round(cy));
      }

      // Record hit rect for every visible face label (all are clickable)
      this.face_name_rects.push({ so: obj.so, x: cx, y: cy, w: tw, h: 10, z: cz, face_index: fi });
    }
  }

  /** Check if a screen point is occluded by any front-facing face from a different object. */
  private is_point_occluded(
    sx: number, sy: number,
    face: number[], verts: vec3[], world: mat4,
    skip_id: string,
  ): boolean {
    if (this.occluding_faces.length === 0) return false;

    // World-space centroid of the face being labeled
    let wx = 0, wy = 0, wz = 0;
    for (const vi of face) {
      const lv = verts[vi];
      const wv = vec4.create();
      vec4.transformMat4(wv, [lv[0], lv[1], lv[2], 1], world);
      wx += wv[0]; wy += wv[1]; wz += wv[2];
    }
    wx /= face.length; wy /= face.length; wz /= face.length;
    const world_centroid: vec3 = [wx, wy, wz];

    // Query spatial index for candidate occluding faces near this screen point
    const candidates = this.occluding_index
      ? this.occluding_index.search(sx, sy, sx, sy)
      : this.occluding_faces.map((_, i) => i);

    for (const fi of candidates) {
      const occ = this.occluding_faces[fi];
      if (occ.obj_id === skip_id) continue;

      // Is the label centroid behind this face's plane?
      const dist = vec3.dot(occ.n, world_centroid) - occ.d;
      if (dist > 0) continue; // in front of this face, not occluded by it

      // Is the screen point inside this face's screen polygon?
      if (this.point_in_polygon_2d(sx, sy, occ.poly)) return true;
    }
    return false;
  }

  /** Ray-casting point-in-polygon test (2D screen space). */
  private point_in_polygon_2d(px: number, py: number, poly: { x: number; y: number }[]): boolean {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const yi = poly[i].y, yj = poly[j].y;
      if ((yi > py) !== (yj > py)) {
        const xi = poly[i].x + (py - yi) / (yj - yi) * (poly[j].x - poly[i].x);
        if (px < xi) inside = !inside;
      }
    }
    return inside;
  }

  private draw_debug_face(face: number[], fi: number, projected: Projected[]): void {
    const rgb = this.FACE_RGB[fi] ?? [128, 128, 128];
    const alpha = debug.enabled ? 1 : 0;
    this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
    this.ctx.beginPath();
    this.ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
    for (let i = 1; i < face.length; i++) {
      this.ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
    }
    this.ctx.closePath();
    this.ctx.fill();
  }

  private render_selection(): void {
    const sel = hits_3d.selection;
    if (!sel || !sel.so.scene) return;

    const projected = hits_3d.get_projected(sel.so.scene.id);
    if (!projected) return;

    this.ctx.fillStyle = 'blue';
    this.render_hit_dots(sel, projected);
  }

  private render_hover(): void {
    const hover = hits_3d.hover;
    if (!hover || !hover.so.scene) return;

    const projected = hits_3d.get_projected(hover.so.scene.id);
    if (!projected) return;

    this.ctx.fillStyle = 'red';
    this.render_hit_dots(hover, projected);
  }

  private render_front_face_label(): void {
    const root_so = get(stores.w_root_so);
    if (!root_so || !root_so.scene?.faces) return;
    const projected = hits_3d.get_projected(root_so.scene.id);
    if (!projected) return;
    const face = hits_3d.front_most_face(root_so);
    const ctx = this.ctx;
    ctx.save();
    ctx.font = '11px monospace';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    let y = 8;
    ctx.fillText(`front: ${face}`, this.size.width - 8, y);
    // Show winding for each face
    for (let i = 0; i < root_so.scene.faces.length; i++) {
      y += 14;
      const w = this.face_winding(root_so.scene.faces[i], projected);
      ctx.fillText(`${i}: ${w < 0 ? '▶' : ' '} ${Math.round(w)}`, this.size.width - 8, y);
    }
    ctx.restore();
  }

  private render_hit_dots(hit: { so: { scene: O_Scene | null }, type: T_Hit_3D, index: number }, projected: Projected[]): void {
    if (!hit.so.scene) return;

    switch (hit.type) {
      case T_Hit_3D.corner:
        this.draw_dot(projected[hit.index]);
        break;
      case T_Hit_3D.edge:
        const [a, b] = hit.so.scene.edges[hit.index];
        const pa = projected[a], pb = projected[b];
        this.draw_dot(pa);
        this.draw_dot(pb);
        this.draw_dot(this.midpoint(pa, pb));
        break;
      case T_Hit_3D.face:
        const face = hit.so.scene.faces![hit.index];
        for (let i = 0; i < face.length; i++) {
          const p1 = projected[face[i]];
          const p2 = projected[face[(i + 1) % face.length]];
          this.draw_dot(p1);
          this.draw_dot(this.midpoint(p1, p2));
        }
        break;
    }
  }

  private draw_dot(p: Projected): void {
    if (p.w < 0) return;
    this.ctx.beginPath();
    this.ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
    this.ctx.fill();
  }

  private midpoint(a: Projected, b: Projected): Projected {
    return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2, z: (a.z + b.z) / 2, w: Math.min(a.w, b.w) };
  }

  // ═══════════════════════════════════════════════════════════════════
  // DIMENSION RENDERING
  // ═══════════════════════════════════════════════════════════════════

  private render_dimensions(): void {
    // Show dimensions for all objects, regardless of selection
    for (const obj of scene.get_all()) {
      const projected = hits_3d.get_projected(obj.id);
      if (!projected) continue;

      const so = obj.so;
      const world_matrix = this.get_world_matrix(obj);

      // In 2D mode, show only the two axes visible on the front face
      const is_2d_mode = stores.current_view_mode() === '2d';
      const front_face = is_2d_mode ? hits_3d.front_most_face(so) : -1;
      const all_axes: Axis[] = (is_2d_mode && front_face >= 0) ? so.face_axes(front_face) : ['x', 'y', 'z'];
      for (const axis of all_axes) {
        this.render_axis_dimension(so, axis, projected, world_matrix);
      }
    }
  }

  private render_axis_dimension(
    so: Smart_Object,
    axis: Axis,
    projected: Projected[],
    world_matrix: mat4
  ): void {
    // Find all silhouette edge candidates for this axis (sorted best → worst)
    const candidates = this.find_best_edge_for_axis(so, axis, projected);
    if (!candidates || candidates.length === 0) return;

    const value = axis === 'x' ? so.width : axis === 'y' ? so.height : so.depth;

    // Try each candidate; stop at the first that isn't occluded
    for (const { v1_idx, v2_idx } of candidates) {
      // Get witness direction in screen space (perpendicular to edge on screen,
      // pointing away from object center). Fixed pixel distances regardless of scale.
      let witness_dir = this.edge_witness_direction(so, v1_idx, v2_idx, axis, projected, world_matrix);

      // Pick direction that points away from cube center
      const verts = so.vertices;
      const v1 = verts[v1_idx], v2 = verts[v2_idx];
      const edge_mid = vec3.fromValues((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2);
      // Vector from SO center to edge midpoint — determines "outward"
      const cx = (so.x_min + so.x_max) / 2;
      const cy = (so.y_min + so.y_max) / 2;
      const cz = (so.z_min + so.z_max) / 2;
      const outward = vec3.fromValues(edge_mid[0] - cx, edge_mid[1] - cy, edge_mid[2] - cz);
      const dot = vec3.dot(witness_dir, outward);
      if (dot < 0) {
        witness_dir = vec3.negate(vec3.create(), witness_dir);
      }

      // Project edge endpoints to screen
      const p1 = projected[v1_idx], p2 = projected[v2_idx];
      if (p1.w < 0 || p2.w < 0) continue;

      // Witness direction in screen space: project witness_dir via world matrix
      const origin_3d = vec3.create();
      const p_origin = this.project_vertex(origin_3d, world_matrix);
      const p_witness = this.project_vertex(witness_dir, world_matrix);
      let wx = p_witness.x - p_origin.x, wy = p_witness.y - p_origin.y;
      const wlen = Math.sqrt(wx * wx + wy * wy);
      if (wlen < 0.001) continue;
      wx /= wlen; wy /= wlen;

      // Fixed pixel distances
      const gap_px = 4;        // gap from edge to witness line start
      const dist_px = 20;      // edge to dimension line
      const ext_px = 8;        // extension past dimension line

      // Build all 6 screen-space points
      const pw1_start: Projected = { x: p1.x + wx * gap_px, y: p1.y + wy * gap_px, z: p1.z, w: p1.w };
      const pw2_start: Projected = { x: p2.x + wx * gap_px, y: p2.y + wy * gap_px, z: p2.z, w: p2.w };
      const pw1_end: Projected = { x: p1.x + wx * (dist_px + ext_px), y: p1.y + wy * (dist_px + ext_px), z: p1.z, w: p1.w };
      const pw2_end: Projected = { x: p2.x + wx * (dist_px + ext_px), y: p2.y + wy * (dist_px + ext_px), z: p2.z, w: p2.w };
      const pd1: Projected = { x: p1.x + wx * dist_px, y: p1.y + wy * dist_px, z: p1.z, w: p1.w };
      const pd2: Projected = { x: p2.x + wx * dist_px, y: p2.y + wy * dist_px, z: p2.z, w: p2.w };

      const drawn = this.draw_dimension_3d(pw1_start, pw1_end, pw2_start, pw2_end, pd1, pd2, value, axis, so);
      if (drawn) break;
    }
  }

  // Algorithm B: Pick the witness direction most perpendicular to the edge on screen.
  // The two candidates are the axes perpendicular to the edge axis in 3D.
  private edge_witness_direction(
    so: Smart_Object,
    v1_idx: number, v2_idx: number,
    edge_axis: Axis,
    projected: Projected[],
    world_matrix: mat4
  ): vec3 {

    // Edge direction on screen
    const ep1 = projected[v1_idx], ep2 = projected[v2_idx];
    const edge_dx = ep2.x - ep1.x, edge_dy = ep2.y - ep1.y;
    const edge_len = Math.sqrt(edge_dx * edge_dx + edge_dy * edge_dy);
    if (edge_len < 0.001) return so.axis_vector('x'); // degenerate
    const edge_ux = edge_dx / edge_len, edge_uy = edge_dy / edge_len;

    // The two candidate witness axes are perpendicular to the edge in 3D
    const all_axes: Axis[] = ['x', 'y', 'z'];
    const candidates = all_axes.filter(a => a !== edge_axis);

    // Project origin and each candidate unit vector to screen
    const origin = vec3.create();
    const p0 = this.project_vertex(origin, world_matrix);

    let best_axis = candidates[0];
    let best_perp = -Infinity;

    for (const axis of candidates) {
      const unit_vec = so.axis_vector(axis);
      const p1 = this.project_vertex(unit_vec, world_matrix);
      const wx = p1.x - p0.x, wy = p1.y - p0.y;

      // Cross product magnitude = perpendicularity (scaled by witness length)
      const cross = Math.abs(edge_ux * wy - edge_uy * wx);

      if (cross > best_perp) {
        best_perp = cross;
        best_axis = axis;
      }
    }

    return so.axis_vector(best_axis);
  }

  // Algorithm A: Find silhouette edges for a given axis, sorted best → worst.
  // A silhouette edge sits on the circumference — one adjacent face is front-facing,
  // the other is back-facing. There are always exactly 2 per axis; prefer the front one.
  // Returns all candidates so the caller can fall back if the best is occluded.
  private find_best_edge_for_axis(
    so: Smart_Object,
    axis: Axis,
    projected: Projected[]
  ): { v1_idx: number; v2_idx: number }[] | null {
    if (!so.scene?.faces) return null;
    const verts = so.vertices;
    const faces = so.scene.faces;
    const edges = so.scene.edges;

    // Build edge→face adjacency: for each edge, find which 2 faces contain it
    const edge_faces = (v1: number, v2: number): number[] => {
      const result: number[] = [];
      for (let fi = 0; fi < faces.length; fi++) {
        const face = faces[fi];
        // Check if both vertices appear adjacent in the face
        for (let i = 0; i < face.length; i++) {
          const a = face[i], b = face[(i + 1) % face.length];
          if ((a === v1 && b === v2) || (a === v2 && b === v1)) {
            result.push(fi);
            break;
          }
        }
      }
      return result;
    };

    type SilhouetteCandidate = {
      v1: number; v2: number;
      front_face: number;  // index of the front-facing adjacent face
    };
    const silhouettes: SilhouetteCandidate[] = [];

    // Check every edge in the topology
    for (const [v1, v2] of edges) {
      // Only consider edges along the target axis
      if (this.edge_axis(verts[v1], verts[v2]) !== axis) continue;

      const adj = edge_faces(v1, v2);
      if (adj.length !== 2) continue;

      const w0 = this.face_winding(faces[adj[0]], projected);
      const w1 = this.face_winding(faces[adj[1]], projected);

      // Silhouette: one front-facing (negative winding), one back-facing (positive)
      if (w0 < 0 && w1 >= 0) {
        silhouettes.push({ v1, v2, front_face: adj[0] });
      } else if (w1 < 0 && w0 >= 0) {
        silhouettes.push({ v1, v2, front_face: adj[1] });
      }
    }

    if (silhouettes.length === 0) return null;

    // Prefer the silhouette edge whose front-facing face is most toward the viewer
    // (most negative winding = most directly facing camera)
    silhouettes.sort((a, b) => {
      const wa = this.face_winding(faces[a.front_face], projected);
      const wb = this.face_winding(faces[b.front_face], projected);
      return wa - wb;  // most negative first
    });

    return silhouettes.map(s => ({ v1_idx: s.v1, v2_idx: s.v2 }));
  }

  // Determine which axis an edge runs along (or null if diagonal)
  private edge_axis(v1: vec3, v2: vec3): Axis | null {
    const dx = Math.abs(v2[0] - v1[0]);
    const dy = Math.abs(v2[1] - v1[1]);
    const dz = Math.abs(v2[2] - v1[2]);
    const eps = 0.01;
    if (dx > eps && dy < eps && dz < eps) return 'x';
    if (dy > eps && dx < eps && dz < eps) return 'y';
    if (dz > eps && dx < eps && dy < eps) return 'z';
    return null;
  }

  /** Collect edge keys for a specific face (for guidance highlight). */
  private face_edge_keys(obj: O_Scene, face_index: number): Set<string> {
    const keys = new Set<string>();
    if (!obj.faces || face_index >= obj.faces.length) return keys;
    const face = obj.faces[face_index];
    for (let i = 0; i < face.length; i++) {
      const a = face[i], b = face[(i + 1) % face.length];
      keys.add(`${Math.min(a, b)}-${Math.max(a, b)}`);
    }
    return keys;
  }

  /** Collect edge keys belonging to front-facing faces (for 2D mode). */
  private front_face_edges(obj: O_Scene, projected: Projected[]): Set<string> {
    const edges = new Set<string>();
    if (!obj.faces) return edges;
    for (const face of obj.faces) {
      if (this.face_winding(face, projected) >= 0) continue; // skip back-facing
      for (let i = 0; i < face.length; i++) {
        const a = face[i], b = face[(i + 1) % face.length];
        edges.add(`${Math.min(a, b)}-${Math.max(a, b)}`);
      }
    }
    return edges;
  }

  // Compute face winding (negative = front-facing with CCW convention)
  private face_winding(face: number[], projected: Projected[]): number {
    if (face.length < 3) return Infinity;
    const p0 = projected[face[0]], p1 = projected[face[1]], p2 = projected[face[2]];
    if (p0.w < 0 || p1.w < 0 || p2.w < 0) return Infinity;
    return (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);
  }

  /** Check if a dimension's text rect is fully occluded by any front-facing face
   *  from a different SO that's closer to the camera.  Depth is computed by
   *  intersecting the camera ray through the dimension center with the face plane. */
  private dimension_occluded(
    cx: number, cy: number, w: number, h: number,
    dim_z: number, owner_id: string,
  ): boolean {
    const hw = w / 2 + 4, hh = h / 2 + 4;  // padding matches Dimensions.hit_test
    const rect_corners = [
      { x: cx - hw, y: cy - hh },
      { x: cx + hw, y: cy - hh },
      { x: cx + hw, y: cy + hh },
      { x: cx - hw, y: cy + hh },
    ];
    const center = { x: cx, y: cy };  // screen point for ray cast

    for (const obj of scene.get_all()) {
      if (obj.so.id === owner_id) continue;
      if (!obj.faces) continue;
      const projected = hits_3d.get_projected(obj.id);
      if (!projected) continue;
      const world = this.get_world_matrix(obj);

      for (const face of obj.faces) {
        if (this.face_winding(face, projected) >= 0) continue;

        // Check all face vertices are in front of camera
        if (face.some(vi => projected[vi].w < 0)) continue;

        // Face polygon must contain all 4 corners of the text rect
        const poly = face.map(vi => ({ x: projected[vi].x, y: projected[vi].y }));
        if (!rect_corners.every(c => this.point_in_polygon_2d(c.x, c.y, poly))) continue;

        // Ray through dimension center → face plane intersection depth
        const face_z = hits_3d.face_depth_at(center, face, obj.so, world);
        if (face_z === null) continue;

        // Face is in front of the dimension → occluded
        if (face_z < dim_z) return true;
      }
    }
    return false;
  }

  /** Draw a dimension line. Returns true if drawn, false if skipped (occluded, clipped, etc.). */
  private draw_dimension_3d(
    w1_start: Projected, w1_end: Projected,
    w2_start: Projected, w2_end: Projected,
    d1: Projected, d2: Projected,
    value: number,
    axis: Axis,
    so: Smart_Object
  ): boolean {
    // Check all points are in front of camera
    if (w1_start.w < 0 || w1_end.w < 0 || w2_start.w < 0 || w2_end.w < 0 || d1.w < 0 || d2.w < 0) return false;

    const ctx = this.ctx;

    // Text setup
    ctx.font = '12px sans-serif';
    const text = units.format_for_system(value, Units.current_unit_system(), stores.current_precision());
    const textWidth = ctx.measureText(text).width;
    const textHeight = 12; // approximate line height

    // Dimension line direction
    const midX = (d1.x + d2.x) / 2, midY = (d1.y + d2.y) / 2;
    const dim_z = (d1.z + d2.z) / 2;

    // Skip if occluded by a different SO's face
    if (this.dimension_occluded(midX, midY, textWidth, textHeight, dim_z, so.id)) return false;

    const dx = d2.x - d1.x, dy = d2.y - d1.y;
    const lineLen = Math.sqrt(dx * dx + dy * dy);
    if (lineLen < 1) return false;
    const ux = dx / lineLen, uy = dy / lineLen;

    // Algorithm C: compute gap as projected text bounding box onto dimension line
    const padding = 8;
    const gap = textWidth * Math.abs(ux) + textHeight * Math.abs(uy) + padding;
    const arrowSize = 20; // space needed for arrows in normal layout

    // Three cases based on available space
    if (lineLen < gap) {
      // Case 3: can't fit text at all — hide (including witness lines)
      return false;
    }

    // Witness lines (only drawn if dimensional is visible)
    ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(w1_start.x, w1_start.y);
    ctx.lineTo(w1_end.x, w1_end.y);
    ctx.moveTo(w2_start.x, w2_start.y);
    ctx.lineTo(w2_end.x, w2_end.y);
    ctx.stroke();

    const halfGap = gap / 2;

    if (lineLen >= gap + arrowSize) {
      // Case 1: normal layout — arrows inside, pointing outward from text
      ctx.beginPath();
      ctx.moveTo(d1.x, d1.y);
      ctx.lineTo(midX - ux * halfGap, midY - uy * halfGap);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(midX + ux * halfGap, midY + uy * halfGap);
      ctx.lineTo(d2.x, d2.y);
      ctx.stroke();

      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      this.draw_arrow(d1.x, d1.y, dx, dy);
      this.draw_arrow(d2.x, d2.y, -dx, -dy);
    } else {
      // Case 2: inverted layout — extension lines go outward, arrows at witness lines point inward
      const extLen = 30; // how far extension lines go past witness lines

      // Extension lines go outward from d1 and d2
      ctx.beginPath();
      ctx.moveTo(d1.x, d1.y);
      ctx.lineTo(d1.x - ux * extLen, d1.y - uy * extLen);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(d2.x, d2.y);
      ctx.lineTo(d2.x + ux * extLen, d2.y + uy * extLen);
      ctx.stroke();

      // Arrows at d1/d2 (witness line positions), pointing inward toward text
      // draw_arrow: tip at (x,y), base extends in (dx,dy) direction
      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      this.draw_arrow(d1.x, d1.y, -dx, -dy);
      this.draw_arrow(d2.x, d2.y, dx, dy);
    }

    // Text centered between d1 and d2
    ctx.fillStyle = 'white';
    ctx.fillRect(midX - textWidth / 2 - 2, midY - textHeight / 2 - 1, textWidth + 4, textHeight + 2);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, midX, midY);

    // Record rect for click-to-edit (z = average depth of dimension line endpoints)
    this.dimension_rects.push({
      axis, so,
      x: midX, y: midY,
      w: textWidth, h: textHeight,
      z: (d1.z + d2.z) / 2,
      face_index: -1,
    });
    return true;
  }

  // ═══════════════════════════════════════════════════════════════════
  // ANGULAR RENDERING — angle annotations between parent and child
  // ═══════════════════════════════════════════════════════════════════
  //
  // Built on intersection lines: the segment where a child face meets a
  // parent face is already computed in world space by render_intersections.
  // The hinge = where that segment meets a parent edge. One witness line
  // runs along the intersection direction, the other along the parent edge.
  // The arc sweeps between them in the parent face plane.

  /** Target screen-space arc radius in pixels (constant for all angulars). */
  private static readonly ANGULAR_ARC_PX = 37;

  private render_angulars(): void {
    if (this.intersection_segments.length === 0) return;

    const identity = mat4.create();

    // Group segments by child SO + parent face → pick best per group
    type SegGroup = typeof this.intersection_segments[number];
    const groups = new Map<string, SegGroup[]>();

    for (const seg of this.intersection_segments) {
      const key = `${seg.child_scene.id}:${seg.parent_face_idx}`;
      let arr = groups.get(key);
      if (!arr) { arr = []; groups.set(key, arr); }
      arr.push(seg);
    }

    const claimed_hinges: vec3[] = [];  // world-space hinge points already used

    for (const segs of groups.values()) {
      // All segs share the same child + parent face. Pick longest segment.
      let best_seg = segs[0];
      let best_len = 0;
      for (const seg of segs) {
        const len = vec3.distance(seg.start, seg.end);
        if (len > best_len) { best_len = len; best_seg = seg; }
      }

      const { start, end, parent_scene, child_scene, parent_face_idx, parent_face_corners } = best_seg;

      // Too-flat check: is the parent face visible enough?
      const parent_projected = hits_3d.get_projected(parent_scene.id);
      if (!parent_projected || !parent_scene.faces) continue;
      const winding = this.face_winding(parent_scene.faces[parent_face_idx], parent_projected);
      if (winding >= 0) continue;
      if (Math.abs(winding) < 8000) continue;

      // ── Hinge: pick intersection endpoint closest to a parent FACE edge ──
      // Use the 4 geometric edges of the parent face (from parent_face_corners),
      // not all visible edges of the SO. This prevents hinge snapping to distant edges.
      const fc = parent_face_corners;
      const face_edges: { w1: vec3; w2: vec3 }[] = [];
      for (let ei = 0; ei < fc.length; ei++) {
        face_edges.push({ w1: fc[ei], w2: fc[(ei + 1) % fc.length] });
      }

      const seg_dir = vec3.sub(vec3.create(), end, start);
      let hinge_w = start;
      let edge_dir_w = vec3.create();

      // Pick the endpoint closest to any parent face edge
      let min_dist = Infinity;
      for (const ep of [start, end]) {
        for (const fe of face_edges) {
          const ab = vec3.sub(vec3.create(), fe.w2, fe.w1);
          const ap = vec3.sub(vec3.create(), ep, fe.w1);
          const t2 = Math.max(0, Math.min(1, vec3.dot(ap, ab) / vec3.dot(ab, ab)));
          const cp = vec3.scaleAndAdd(vec3.create(), fe.w1, ab, t2);
          const dist = vec3.distance(ep, cp);
          if (dist < min_dist) {
            min_dist = dist;
            hinge_w = ep;
            vec3.normalize(edge_dir_w, ab);
          }
        }
      }

      // Hinge is geometrically on a parent face edge by construction — no floater check needed.
      const hinge_scr = this.project_vertex(hinge_w, identity);
      if (hinge_scr.w < 0) continue;

      // ── Witness directions (world space) ──
      // Witness A: along the intersection line (child's rotated direction)
      const isect_dir_w = vec3.sub(vec3.create(), end, start);
      vec3.normalize(isect_dir_w, isect_dir_w);
      // Orient isect_dir_w to point away from hinge into the segment
      const hinge_to_mid = vec3.scaleAndAdd(vec3.create(), start, seg_dir, 0.5);
      vec3.sub(hinge_to_mid, hinge_to_mid, hinge_w);
      if (vec3.dot(isect_dir_w, hinge_to_mid) < 0) {
        vec3.negate(isect_dir_w, isect_dir_w);
      }

      // Witness B: along the parent edge (parent's unrotated axis)
      // Orient edge_dir_w to point toward the interior of the parent face
      const face_center = vec3.create();
      for (const c of fc) vec3.add(face_center, face_center, c);
      vec3.scale(face_center, face_center, 0.25);
      const to_center = vec3.sub(vec3.create(), face_center, hinge_w);
      if (vec3.dot(edge_dir_w, to_center) < 0) {
        vec3.negate(edge_dir_w, edge_dir_w);
      }

      // ── Angle between witness lines ──
      const dot = Math.max(-1, Math.min(1, vec3.dot(isect_dir_w, edge_dir_w)));
      const angle = Math.acos(dot);
      const degrees = angle * 180 / Math.PI;
      if (degrees < 0.5 || degrees > 89.5) continue;

      // ── Determine rotation axis for Angular.ts commit ──
      // The parent face normal tells us which axis is fixed (perpendicular to the face)
      const parent_so = parent_scene.so;
      const face_fixed = parent_so.face_fixed_axis(parent_face_idx);
      const rotation_axis: Axis = face_fixed; // rotation is around the axis perpendicular to the face

      // ── Radius: constant screen size ──
      const hinge_screen = this.project_vertex(hinge_w, identity);
      if (hinge_screen.w < 0) continue;
      const probe = vec3.scaleAndAdd(vec3.create(), hinge_w, isect_dir_w, 1.0);
      const probe_screen = this.project_vertex(probe, identity);
      if (probe_screen.w < 0) continue;
      const px_per_unit = Math.sqrt(
        (probe_screen.x - hinge_screen.x) ** 2 +
        (probe_screen.y - hinge_screen.y) ** 2
      );
      if (px_per_unit < 0.001) continue;
      const radius_w = Render.ANGULAR_ARC_PX / px_per_unit;

      // Skip if another angular already claimed essentially the same hinge point
      const hinge_radius_px = 6;
      const collides = claimed_hinges.some(ch => {
        const ch_scr = this.project_vertex(ch, identity);
        if (ch_scr.w < 0) return false;
        const dx = hinge_screen.x - ch_scr.x, dy = hinge_screen.y - ch_scr.y;
        return (dx * dx + dy * dy) < hinge_radius_px * hinge_radius_px;
      });
      if (collides) continue;

      claimed_hinges.push(vec3.clone(hinge_w));

      this.render_angular(
        child_scene.so, hinge_w, isect_dir_w, edge_dir_w,
        angle, radius_w, rotation_axis, identity,
      );
    }
  }

  /** Render one angular. All geometry in world space, projected through identity. */
  private render_angular(
    so: Smart_Object,
    hinge_w: vec3,
    dir_a_w: vec3,   // witness A direction (intersection line = child's rotated axis)
    dir_b_w: vec3,   // witness B direction (parent edge = unrotated axis)
    angle: number,
    radius_w: number,
    rotation_axis: Axis,
    identity: mat4,
  ): void {
    const degrees = angle * 180 / Math.PI;

    // Project hinge to screen
    const origin = this.project_vertex(hinge_w, identity);
    if (origin.w < 0) return;

    // Orthonormal basis in the arc plane: u = dir_b_w, v = perp toward dir_a_w
    const v_perp = this.perp_component(dir_a_w, dir_b_w);
    const vp_len = Math.sqrt(v_perp[0] ** 2 + v_perp[1] ** 2 + v_perp[2] ** 2);
    if (vp_len < 1e-6) return;

    // Sample the arc in world space: from dir_b_w (t=0) toward dir_a_w (t=angle)
    const segments = 24;
    const arc_points: Projected[] = [];
    for (let i = 0; i <= segments; i++) {
      const t = (i / segments) * angle;
      const cos_t = Math.cos(t), sin_t = Math.sin(t);
      const point: vec3 = [
        hinge_w[0] + radius_w * (cos_t * dir_b_w[0] + sin_t * v_perp[0]),
        hinge_w[1] + radius_w * (cos_t * dir_b_w[1] + sin_t * v_perp[1]),
        hinge_w[2] + radius_w * (cos_t * dir_b_w[2] + sin_t * v_perp[2]),
      ];
      const projected = this.project_vertex(point, identity);
      if (projected.w < 0) return;
      arc_points.push(projected);
    }

    // Short witness lines: from hinge to 1.3 × radius along each direction
    const witness_length = radius_w * 1.3;
    const witness_a_end = this.project_vertex(
      vec3.scaleAndAdd(vec3.create(), hinge_w, dir_a_w, witness_length), identity);
    const witness_b_end = this.project_vertex(
      vec3.scaleAndAdd(vec3.create(), hinge_w, dir_b_w, witness_length), identity);

    if (witness_a_end.w < 0 || witness_b_end.w < 0) return;

    // Text at arc midpoint
    const mid_index = Math.floor(segments / 2);
    const text_position = arc_points[mid_index];
    const ctx = this.ctx;
    ctx.font = '12px sans-serif';
    const text = degrees.toFixed(1) + '°';
    const text_width = ctx.measureText(text).width;
    const text_height = 12;

    // Compute gap in arc indices for text
    const segment_dx = arc_points[mid_index + 1].x - arc_points[mid_index].x;
    const segment_dy = arc_points[mid_index + 1].y - arc_points[mid_index].y;
    const segment_length = Math.sqrt(segment_dx * segment_dx + segment_dy * segment_dy);
    const gap_segments = segment_length > 0.5 ? Math.ceil((text_width / 2 + 6) / segment_length) : segments;
    const gap_start = Math.max(0, mid_index - gap_segments);
    const gap_end = Math.min(segments, mid_index + gap_segments);

    // Total projected arc length
    let total_arc_length = 0;
    for (let i = 0; i < segments; i++) {
      const pdx = arc_points[i + 1].x - arc_points[i].x;
      const pdy = arc_points[i + 1].y - arc_points[i].y;
      total_arc_length += Math.sqrt(pdx * pdx + pdy * pdy);
    }
    if (total_arc_length < 2) return;

    // Crunch: decide normal vs inverted layout
    const arrow_space = 20;
    const inverted = total_arc_length < (text_width + 16 + arrow_space);

    // Draw
    ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)';
    ctx.lineWidth = 1;

    // Witness lines from hinge
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(witness_a_end.x, witness_a_end.y);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(witness_b_end.x, witness_b_end.y);
    ctx.stroke();

    if (!inverted) {
      // Normal: arc between witness lines with gap for text
      // Always draw at least 3 segments from each end (stub near arrowhead)
      const min_stub = 3;
      const draw_start = Math.max(gap_start, min_stub);
      const draw_end = Math.min(gap_end, segments - min_stub);
      ctx.beginPath();
      ctx.moveTo(arc_points[0].x, arc_points[0].y);
      for (let i = 1; i <= Math.min(draw_start, segments); i++) ctx.lineTo(arc_points[i].x, arc_points[i].y);
      ctx.stroke();
      if (draw_end < segments) {
        ctx.beginPath();
        ctx.moveTo(arc_points[Math.max(draw_end, 0)].x, arc_points[Math.max(draw_end, 0)].y);
        for (let i = Math.max(draw_end, 0) + 1; i <= segments; i++) ctx.lineTo(arc_points[i].x, arc_points[i].y);
        ctx.stroke();
      }

      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      const a0 = arc_points[0], a1 = arc_points[Math.min(3, segments)];
      this.draw_arrow(a0.x, a0.y, a1.x - a0.x, a1.y - a0.y);
      const arc_end = arc_points[segments], arc_prev = arc_points[Math.max(0, segments - 3)];
      this.draw_arrow(arc_end.x, arc_end.y, arc_prev.x - arc_end.x, arc_prev.y - arc_end.y);
    } else {
      // Inverted: extension arcs outside, adaptive to reach target screen-space length
      const ext_target_px = 20;
      const fine_step = Math.PI / 180;  // 1° increments
      const max_steps = 90;             // cap at 90°

      // Extension arc before witness B (t < 0)
      const ext_b_pts: Projected[] = [];
      ext_b_pts.push(arc_points[0]);
      for (let i = 1; i <= max_steps; i++) {
        const t = -(i * fine_step);
        const cos_t = Math.cos(t), sin_t = Math.sin(t);
        const pt: vec3 = [
          hinge_w[0] + radius_w * (cos_t * dir_b_w[0] + sin_t * v_perp[0]),
          hinge_w[1] + radius_w * (cos_t * dir_b_w[1] + sin_t * v_perp[1]),
          hinge_w[2] + radius_w * (cos_t * dir_b_w[2] + sin_t * v_perp[2]),
        ];
        const p = this.project_vertex(pt, identity);
        ext_b_pts.push(p);
        const dx = p.x - ext_b_pts[0].x, dy = p.y - ext_b_pts[0].y;
        if (Math.sqrt(dx * dx + dy * dy) >= ext_target_px) break;
      }
      ctx.beginPath();
      ctx.moveTo(ext_b_pts[ext_b_pts.length - 1].x, ext_b_pts[ext_b_pts.length - 1].y);
      for (let i = ext_b_pts.length - 2; i >= 0; i--) ctx.lineTo(ext_b_pts[i].x, ext_b_pts[i].y);
      ctx.stroke();

      // Extension arc after witness A (t > angle)
      const ext_a_pts: Projected[] = [];
      ext_a_pts.push(arc_points[segments]);
      for (let i = 1; i <= max_steps; i++) {
        const t = angle + i * fine_step;
        const cos_t = Math.cos(t), sin_t = Math.sin(t);
        const pt: vec3 = [
          hinge_w[0] + radius_w * (cos_t * dir_b_w[0] + sin_t * v_perp[0]),
          hinge_w[1] + radius_w * (cos_t * dir_b_w[1] + sin_t * v_perp[1]),
          hinge_w[2] + radius_w * (cos_t * dir_b_w[2] + sin_t * v_perp[2]),
        ];
        const p = this.project_vertex(pt, identity);
        ext_a_pts.push(p);
        const dx = p.x - ext_a_pts[0].x, dy = p.y - ext_a_pts[0].y;
        if (Math.sqrt(dx * dx + dy * dy) >= ext_target_px) break;
      }
      ctx.beginPath();
      ctx.moveTo(ext_a_pts[0].x, ext_a_pts[0].y);
      for (let i = 1; i < ext_a_pts.length; i++) ctx.lineTo(ext_a_pts[i].x, ext_a_pts[i].y);
      ctx.stroke();

      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      const eb = ext_b_pts[Math.min(3, ext_b_pts.length - 1)];
      this.draw_arrow(ext_b_pts[0].x, ext_b_pts[0].y, eb.x - ext_b_pts[0].x, eb.y - ext_b_pts[0].y);
      const ea = ext_a_pts[Math.min(3, ext_a_pts.length - 1)];
      this.draw_arrow(ext_a_pts[0].x, ext_a_pts[0].y, ea.x - ext_a_pts[0].x, ea.y - ext_a_pts[0].y);
    }

    // For very crunched angulars, push text outward so it doesn't occlude arrowheads
    let tx = text_position.x, ty = text_position.y;
    if (inverted && total_arc_length < arrow_space) {
      const dx = text_position.x - origin.x;
      const dy = text_position.y - origin.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 0.5) {
        const push = text_height / 2 + 10;
        tx = text_position.x + (dx / dist) * push;
        ty = text_position.y + (dy / dist) * push;
      }
    }

    // Text
    ctx.fillStyle = 'white';
    ctx.fillRect(tx - text_width / 2 - 2, ty - text_height / 2 - 1, text_width + 4, text_height + 2);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, tx, ty);

    // Record for hit testing / click-to-edit
    this.angular_rects.push({
      rotation_axis, angle_degrees: degrees, so,
      x: tx, y: ty, w: text_width, h: text_height,
      z: origin.z, face_index: -1,
    });
  }

  /** Get the unit vector perpendicular to u in the plane of u and v (toward v). */
  private perp_component(v: vec3, u: vec3): vec3 {
    // v_perp = normalize(v - (v·u)*u)
    const dot = vec3.dot(v, u);
    const perp: vec3 = [v[0] - dot * u[0], v[1] - dot * u[1], v[2] - dot * u[2]];
    const len = Math.sqrt(perp[0] ** 2 + perp[1] ** 2 + perp[2] ** 2);
    if (len < 1e-8) return [0, 0, 0];
    return [perp[0] / len, perp[1] / len, perp[2] / len];
  }

  private draw_arrow(x: number, y: number, dx: number, dy: number): void {
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len < 1) return;

    const ux = dx / len, uy = dy / len;
    const size = 6;

    // Arrow head pointing in direction (dx, dy)
    const ctx = this.ctx;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + ux * size - uy * size * 0.5, y + uy * size + ux * size * 0.5);
    ctx.lineTo(x + ux * size + uy * size * 0.5, y + uy * size - ux * size * 0.5);
    ctx.closePath();
    ctx.fill();
  }
}

export const render = new Render();
