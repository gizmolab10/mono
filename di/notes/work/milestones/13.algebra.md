# M13 Algebra

**Started:** 2026-02-07
**Status:** compile tree in progress

## Problem

Bounds are independent — change width, nothing else moves. That's fine for direct editing, but useless for constraints like `door.height = wall.height - 6"`. Need an expression engine that compiles formulas into trees, evaluates forward, and propagates changes back.

## Goal

Recursive descent compiler. Parse algebraic expressions into a tree. Traverse forward (evaluate) and reverse (propagate). Wire into Smart Objects so attribute formulas actually do something.

## Compile Tree

The tree is an AST. Each node has a type and knows how to evaluate itself.

### Node types

```
Node
├── Literal      → constant number (in mm)
├── Reference    → pointer to an SO attribute (e.g., wall.height)
├── BinaryOp     → left op right  (+, -, *, /)
├── UnaryOp      → -expr (negation)
└── Group        → (expr) — parenthesized subexpression
```

### Grammar

```
expression  →  term (('+' | '-') term)*
term        →  factor (('*' | '/') factor)*
factor      →  '-' factor | atom
atom        →  NUMBER | UNIT_LITERAL | REFERENCE | '(' expression ')'
```

- `NUMBER` = `3.5`, `42`
- `UNIT_LITERAL` = `6"`, `5'`, `2.5 mm` — parsed via Units.ts into mm
- `REFERENCE` = `wall.height`, `door.x_min` — dot-path to SO attribute

### Example

`wall.height - 6"` compiles to:

```
BinaryOp(-)
├── Reference("wall", "height")
└── Literal(152.4)      // 6" = 152.4mm
```

### Files

| File | Purpose |
|------|---------|
| `algebra/Node.ts` | Node types (the tree) |
| `algebra/Tokenizer.ts` | String → token stream |
| `algebra/Compiler.ts` | Token stream → Node tree (recursive descent) |
| `tests/Compiler.test.ts` | Tests |

## Phases

- [ ] **1. compile tree** — node types, tokenizer, recursive descent parser
	- [ ] tokenize literals, references, operators
	- [ ] parse precedence (`1 + 2 * 3` → mul binds tighter)
	- [ ] parse parentheses
	- [ ] parse unit literals (`6"`, `5'`, `2.5 mm`)
	- [ ] parse references (`wall.height`)
	- [ ] error on malformed input
- [ ] **2. traverse and reverse traverse** — evaluate forward, propagate backward
	- [ ] forward eval with mock SO values
	- [ ] reverse propagate simple cases (`a = b - 6` → change `a`, update `b`)
	- [ ] cycle detection
- [ ] **3. incorporate into SO** — formula field on Attribute, propagation hook in Editor
	- [ ] formula on Attribute triggers eval
	- [ ] Editor commit triggers propagation
	- [ ] serialize/deserialize formulas
