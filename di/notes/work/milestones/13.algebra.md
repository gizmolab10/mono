# M13 Algebra

**Started:** 2026-02-07
**Status:** phases 1-2 done, phase 3 next

## Problem

Bounds are independent — change width, nothing else moves. That's fine for direct editing, but useless for constraints like `door.height = wall.height - 6"`. Need an expression engine that compiles formulas into trees, evaluates forward, and propagates changes back.

## Goal

Recursive descent compiler. Parse algebraic expressions into a tree. Traverse forward (evaluate) and reverse (propagate). Wire into Smart Objects so attribute formulas actually do something.

## Compile Tree

The tree is an AST. Each node has a type and knows how to evaluate itself.

### Node types

```
Node
├── Literal      → constant number (in mm)
├── Reference    → pointer to an SO attribute (e.g., wall.height)
├── BinaryOp     → left op right  (+, -, *, /)
├── UnaryOp      → -expr (negation)
└── Group        → (expr) — parenthesized subexpression
```

### Grammar

```
expression  →  term (('+' | '-') term)*
term        →  factor (('*' | '/') factor)*
factor      →  '-' factor | atom
atom        →  NUMBER | UNIT_LITERAL | REFERENCE | '(' expression ')'
```

- `NUMBER` = `3.5`, `42`
- `UNIT_LITERAL` = `6"`, `5'`, `2.5 mm` — parsed via Units.ts into mm
- `REFERENCE` = `wall.height`, `door.x_min` — dot-path to SO attribute

### Example

`wall.height - 6"` compiles to:

```
BinaryOp(-)
├── Reference("wall", "height")
└── Literal(152.4)      // 6" = 152.4mm
```

### Files

| File | Lines |
|------|-------|
| `algebra/Node.ts` | Node types — literal, reference, binary, unary |
| `algebra/Tokenizer.ts` | String → token stream, handles unit suffixes via Units.ts |
| `algebra/Compiler.ts` | Recursive descent parser — expression/term/factor/atom |
| `algebra/Evaluate.ts` | Forward eval, reverse propagation, cycle detection |
| `tests/Compiler.test.ts` | 35 tests — tokenizer + parser |
| `tests/Evaluate.test.ts` | 26 tests — eval, propagate, cycles |

## Phases

- [x] **1. compile tree** — node types, tokenizer, recursive descent parser
	- [x] tokenize literals, references, operators
	- [x] parse precedence (`1 + 2 * 3` → mul binds tighter)
	- [x] parse parentheses
	- [x] parse unit literals (`6"`, `5'`, `2.5 mm`)
	- [x] parse references (`wall.height`)
	- [x] error on malformed input
- [x] **2. traverse and reverse traverse** — evaluate forward, propagate backward
	- [x] forward eval with mock SO values
	- [x] reverse propagate simple cases (`a = b - 6` → change `a`, update `b`)
	- [x] cycle detection
- [ ] **3. incorporate into SO** — formula field on Attribute, propagation hook in Editor
	- [ ] formula on Attribute triggers eval
	- [ ] Editor commit triggers propagation
	- [ ] serialize/deserialize formulas
