# Repeaters

i want a way to automagically add/remove repeated elements like stairs (range for rise), studs (local building code)

## Examples

- stairs: template = one step (w, rise, run) → count from gap range constraint
- studs: template = one stud (w, h, thickness) → count from spacing constraint

---

## Phase 1 — Data model

- [x] add `repeater` to Smart_Object
- [x] add `is_template: boolean` flag to Smart_Object (marks the first child as the template)
- [x] serialize/deserialize both fields in Smart_Object

## Phase 2 — Engine: generate copies

- [x] `Engine.sync_repeater(so)` — marks first child as template, syncs clones
- [x] `Engine.sync_repeater(so)` — evaluates count, creates/removes cloned children to match
  - clones copy template's dimensions
  - each clone's position offset = template size × index (axis determined by template's largest dimension)
- [x] decompose: call `sync_repeater` after any propagation that touches a repeater SO

## Phase 3 — Constraints integration

- [x] when `propagate(so)` runs and `so` is a repeater, call `sync_repeater(so)` after
- [x] when `propagate_all()` runs, sync all repeater SOs after

## Phase 4 — UI

- [x] D_Selection: "repeat" button → marks SO as repeater, shows constraint options
- [x] D_List: badge repeated children with dim styling (e.g. `×3`)

## Phase 5 — Examples / test

- [x] build a stairs preset in the library (step SO + repeater parent)
- [x] build a studs preset (stud SO + repeater parent with code-derived spacing)

## Design insight — no modes

stairs are just linear repeaters. a staircase is a parent SO rotated at `atan(height/length)`, with steps repeating linearly along the hypotenuse. studs, joists, and ramps are the same — linear repeat, different template shape and parent orientation. no mode field needed.

the user's mental model: "i want a reasonable staircase from origin to extent." they set the envelope (height × length), the system picks a count that puts the gap (rise) within an acceptable range. rise and run fall out of the geometry — they're feedback, not input.

**what distinguishes use cases is the template shape + parent rotation + constraints:**

| Thing        | Template shape        | Parent rotation          | Constraint                      |
| ------------ | --------------------- | ------------------------ | ------------------------------- |
| Stairs       | step (wide, shallow)  | atan(h/l) on repeat_axis | gap_min/gap_max (rise range)    |
| Studs        | stud (tall, narrow)   | none                     | spacing (discrete: 12/16/24 OC) |
| Floor joists | joist (long, shallow) | none                     | spacing (discrete: 12/16/24 OC) |
| Roof joists  | joist (long, shallow) | pitch angle              | spacing (discrete: 12/16/24 OC) |


**validation — phantom stairs:** extend the stair pattern by one in each direction. step[-1] should sit just below floor. step[count] should land just beyond the top. if both match, the geometry is right.

---

## Phase 6 — Repeater expansion

### Phase 6.1 — Data model

- [x] add `repeat_axis?: 0 | 1` to repeater — which axis clones march along (never 2)
- [x] add `gap_min?: number` / `gap_max?: number` to repeater — constrained spacing range (mm)
- [x] add `spacing?: number` to repeater — discrete spacing quick-pick (mm)
- [x] no mode field — linear handles everything
- [x] serialize/deserialize new fields in Smart_Object
- [x] migrate: v6→v7, existing repeaters unchanged (new fields are all optional)

### Phase 6.2 — Engine: resolve_gap + repeat_axis

- [x] `resolve_gap(total_length, gap_min, gap_max)` — find count where `total_length / count` falls within [min, max]; prefer even division, fall back to closest
- [x] `sync_repeater` uses `repeat_axis` when set (falls back to current auto-detect from largest template dimension)
- [x] when `gap_min`/`gap_max` set: count = `resolve_gap(parent_length_along_repeat_axis, gap_min, gap_max)`
- [x] when `spacing` set: count = `parent_length / spacing` (rounded)
- [x] repeater fields update via spread (not overwrite)

### Phase 6.3 — UX

- [x] repeat_axis selector (x / y toggle) in D_Selection when repeater is active
- [x] gap range inputs (min/max) — shown when gap_min/gap_max are set; prefilled 152.4 / 203.2 mm for stairs
- [x] spacing quick-pick: segmented control (12" / 16" / 24") — shown when spacing is set
- [x] display: resolved gap, count, total length

### Phase 6.4 — Presets

- [x] stairs .di file: root SO (stair envelope, rotated) + template step child + repeater with gap_min/gap_max
- [x] studs .di file: root SO (wall frame) + template stud child + repeater with spacing + repeat_axis

See [user manual/repeaters](../../user manual/repeaters.md)

### Phase 6.5 — Test

- [x] stairs: phantom stair validation, gap clamping, envelope resize adjusts count
- [x] studs: three spacings, wall length changes, axis toggle
- [x] joists: same as studs but template is horizontal — verify repeat works
- [x] existing linear repeaters unchanged (regression)


### Phase 7 — Improvements

- [x] firewall blocking: horizontal member at mid-height between studs
- [x] firewall toggle in repeater UI (axis row, pill button)
- [x] bookend bay fire block with 2" minimum gap
- [ ] stairs: parent rotated at staircase angle, steps repeat linearly along hypotenuse — no special diagonal code
- [ ] for stretch, add header and footer
- [ ] for stairs, add stringers

