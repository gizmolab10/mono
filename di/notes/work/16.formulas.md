# Design of formulas

- [ ] simplest mental model
- [ ] read [[algebra]]
- [ ] all plain attributes (eg, "x") refer to parent SO
- [ ] SO name.attribute name -> reference an non-parent SO
- [ ] empty formula -> silently use parent.attribute + value
- [ ] for attributes with invariant = true -> use default derived formula

## Examples

For the "x" row:

| Formula     | Resolves to            |
| ----------- | ---------------------- |
| *(empty)*   | `parent.x_min + x_min` |
| `x * 2`     | `parent.x_min * 2`     |
| `A.x * 2`   | `A.x_min * 2`          |
| `A.x + B.X` | `A.x_min + B.x_max`    |

## Proposal

**Mental model:** `x * 2` means "my x is parent's x times two." Only name another SO when you mean something other than your parent. Empty formula = `parent.attribute + value` — the default relationship every child already has.

Per architecture, aliases go in `Constraints.resolve` and `.write`. Tokenizer, compiler, evaluator stay untouched.

### Four changes, in order

1. **Alias map in Constraints** — `resolve_alias(attribute)` maps `x` → `x_min`, `y` → `y_min`, `w` → computed width, etc. Called inside `resolve()` before `get_bound()`. Derived aliases (`w`, `h`, `d`) compute from two bounds (`x_max - x_min`). Reverse propagation: writing `w = 300` sets `x_max = x_min + 300`.

2. **Bare attribute → parent reference** — bare identifier like `x` (no dot) currently throws. Change: bare identifier → reference to parent SO with that attribute. `x * 2` tokenizes as `{ type: 'reference', object: <parent_id>, attribute: 'x' }`. Needs parent id passed into tokenizer context or resolved later in Constraints.

3. **Empty formula default** — when formula is empty/null, Constraints silently treats it as `parent.<attribute> + <current_value>`. The identity relationship — child at offset from parent.

4. **Invariant-derived formulas** — when an attribute has `invariant = true`, it's not a source of truth — it's derived from the other two in its axis. Constraints generates its formula from the alias map's "For Invariant" column: if `x` is invariant, `x` → `X - w` (position derived from far edge minus width). Only one attribute per axis can be invariant. The other two are edited directly; the invariant one recomputes.

### Tests

- Alias resolution: `x` → `x_min`, `X` → `x_max`, `w` → width
- Bare attribute: `x * 2` with parent context → `parent.x_min * 2`
- Cross-SO reference: `A.x * 2` → `A.x_min * 2`
- Empty formula: evaluates to `parent.x_min + value`
- Reverse propagation through aliases: change result, `w` updates `x_max`
- Invariant default: marking `x` as invariant gives it formula `X - w`; changing `X` or `w` recomputes `x`
- Only one invariant per axis: marking `x` invariant means `w` and `X` stay editable