# Quaternions

How does a child orient itself relative to its parent? Right now the answer is a quaternion — a black box that stores rotation. But a quat alone doesn't tell you *which angles the user is thinking in*. Decomposition is the heart of it: how do we break a rotation into angles that feel intuitive, that map to the angular decorations on screen, that the user can click and edit?

## Migration Plan

### Strategy

Revert `render_angulars` (the orchestrator that depends on intersection segments) but keep `render_angular` (the drawing function — arcs, witness lines, arrowheads, text). Build the SO 2-tuple storage first, then wire a new orchestrator that reads from it.

This will result in a UX with "instant compound angle computation!"

tthis is the kind of "really?" moment I had 20 years ago when i got curious about the algebraic compile tree to see if it could traverse backwards and solve x for y. hah, easy stuff these days but rare back then

### Phase 1 — Add rotation pairs to Smart_Object

Add a `rotations` field: array of `{axis: Axis, angle: number}`, max length 2, axes frozen on first use.

Methods:
- `apply_rotation(axis, delta_radians)` — if axis matches an existing entry, merge; if new and length < 2, push; if new and length = 2, compose into quat + decompose back into the frozen pair
- `recompute_orientation()` — compose the pair into `this.orientation` (quat) via sequential `setAxisAngle` + `multiply`
- `decompose_into(axes)` — given two frozen axes, decompose a quat into two angles. Six cases (XY, XZ, YX, YZ, ZX, ZY), each with specific atan2 formulas on rotation matrix elements

Update serialization: save `rotations` array, restore on load, derive quat on deserialize.

### Phase 2 — Update rotation call sites

- `Angular.ts:commit()` — change from `quat.setAxisAngle` to `so.apply_rotation(axis, radians)`, let SO recompute quat
- `Orientation.from_bounds()` — produce `{axis, angle}` entry instead of raw quat, or call `apply_rotation`

### Phase 3 — Rewrite render_angulars

New orchestrator reads from `so.rotations[]` directly. For each entry `{axis, angle}`:
- Pick the most visible parent face perpendicular to that axis
- Compute hinge point on a parent face edge (same parent-face-edge logic we already have)
- Compute witness directions from axis + angle
- Call existing `render_angular()` to draw

No intersection segments needed. No `intersect_face_pair`. No borderline clipping. Angulars stop blinking.

### Phase 4 — Clean up

Remove intersection-segment code from the angular pipeline. `render_intersections` may still be needed for visual intersection lines (if we draw them), but angulars no longer depend on it.

### However, regarding compound situations...

after compaction, the first of those tuples will render crazy. so, i need to think a bit more about the user experience.

a hinge point can be at any point on the parent's edge that we decide on and no matter what, the non-parent witness line will look floaty.

where is the best hinge point? i need to visualize how the witness lines (the ones that are NOT on a parent edge) will appear, and how much different than a nearby intersection line to which it corresponds. Will it seem to correspond or will it be crazy voodoo?

a child C has an intersection line L on its parent's face F. The normal to F is the axis A, the first of the tuple. The hinge point H is on the the edge E of F. Consider placing H where L meets E. Where does the witness line point? is it inside or outside of C?
#### it is inside

C's quat is compound: rotation θ₁ around A (normal to F), then θ₂ around B. The intersection line L on face F exists because C's bottom face (originally coplanar with F) has been rotated away. L is where C's rotated bottom face still touches F — the crease.

L's direction is determined by the _full_ compound rotation. It's the line where C's rotated bottom plane intersects F's plane. Both rotations contribute to where L ends up.

The decomposed angular for axis A wants to show θ₁ alone. Its witness line direction is: "where would C's edge be if only θ₁ existed?" That's a rotation of the parent edge direction by θ₁ around A.

But L — the actual intersection crease — reflects the compound rotation. L is rotated by _both_ θ₁ and θ₂ relative to the parent edge.

So at hinge H (where L meets E), the witness line for θ₁ points in a _different direction_ than L. L goes one way (compound), the witness goes another (θ₁ only). The angle between them is the "contamination" from θ₂.

Does the witness point inside or outside C? It points _between_ the parent edge and L. The full rotation swings the crease further than θ₁ alone would. So the θ₁ witness line lands inside the angular opening — inside the wedge between parent edge and intersection crease, which means it passes through C's interior, not outside it.

## My tentative answer

The app refuses to rotate around an arbitrary axis. Rotation is always confined to a single axis of the parent. This rotation is stored. So are all subsequent rotations. Consecutive rotations about one axis are merged. Perhaps we can assume that, under typical (non-hostile) use, this SOT will not grow much.

### Compaction algorithm

instead of an unbounded array of rotations, we may only need two. Use case A: rotate around X, rotate around Y. that's two. now rotate around X, get a quat, decompose it into a rotation around X and then one around Y. Bing! Use case B: then after all that, rotate around Z. This is easy. It can still be decomposed around X and Y same ordering. Bing! So each SO must contain two tuples: the two axes, in the original order, and never changed thereafter, and two rotations about those two axes, respectively. or if you like, one tuple of {which axis, what rotation}.

#### What does the user see?

Use case A: rotate around X, one angular appears. rotate around Y, a second angular appears. rotate around X, both angulars change, right? Perhaps the user will be startled. However, in cabinetry and architecture, dual axis manipulation is rare, and the exceptions are expected to be behave in an exotic manner, compound angles are reputed to be a head scratcher, so having an app that does it fast and reliably is happiness and joy.

## The big question

- [ ] how should quaternions be decomposed?
	- [ ] is the decomposition (rotations around two parent axes) the source of truth, with the quat derived from it?
	- [ ] which two axes?
	- [ ] in what order? (order matters — rotation is not commutative)
### Where we are now

Currently every child's orientation is a single-axis rotation. `Angular.ts:commit()` does `quat.setAxisAngle(so.orientation, axis_vec, radians)` — overwrites the entire quat with one rotation. `Orientation.from_bounds()` also produces single-axis quats. There's never a compound case.

But a child has 2 degrees of rotational freedom relative to its parent (max 2 angulars per child). Supporting compound rotations means decomposing the quat into two sequential single-axis rotations — essentially Euler angles, with all their order-dependence and convention choices.

A quat CAN be decomposed into two angles relative to identity. The decomposition is a sequence of single-axis rotations: extract the first axis component, remove it, the remainder is the second. But the result depends on convention — which axis first.

### What this decides

Everything downstream flows from this choice:
- How angulars are rendered (one or two per child)
- How angle editing works (clicking an angular → which axis, which angle)
- Whether the quat is derived or authoritative
- How constraints propagate through compound rotations

## Capacity rule

A child has exactly 2 degrees of rotational freedom relative to its parent. So: **max angulars = 2 x number of children**, regardless of hierarchy depth or structure.

---

## Angular rendering: what we built and what broke

### Spec

- [ ] for parent P and child C, show C's rotation angle(s) at a hinge point
- [ ] draw two witness lines and an arc with the angle in degrees
	- [ ] short witness lines — `1.3 x radius` from hinge point
	- [ ] radius of arc: constant screen-space size across all angulars
- [ ] the arc must be in a plane parallel to a face of P (perpendicular to the rotation axis)
	- [ ] pick the most visible face, skip if too flat
- [ ] arc ends in arrowheads pointing at witness lines
- [ ] arc has two sections, one on either side of the text
- [ ] use the dimensionals algorithm for inside/outside placement

### Key insight: reuse intersection lines

The intersection line where a child face meets a parent face gives us everything: the arc plane (the parent face), one witness direction (the intersection line = child's rotated axis), the hinge (where the intersection meets a parent edge), and the other witness direction (the parent edge = unrotated reference).

### Existing infrastructure

- **`Angle_Rect`** (`Interfaces.ts`): extends `Label_Rect` with `rotation_axis` and `angle_degrees`
- **`Angular.ts`** (`editors/Angular.ts`): hit test, begin/commit/cancel editing cycle
- **`Render.ts`**: `angular_rects[]` cleared each frame, `render_angulars()` + `render_angular()`
- **Hit testing + events**: wired through `Hits_3D`, `Events_3D`, `Graph.svelte`

### Coordinate frame discipline

All angular geometry in **world space**, projected through `identity`. Never project child-local through parent world matrix. Intersection endpoints and parent face corners are already world-space.

### Implementation: intersection-based pipeline

`render_intersections` collects segments → `render_angulars` groups by child+parent_face, picks longest, selects hinge on parent face edge, computes witness directions, draws.

### The floater saga

Hinge selection went through many iterations:

1. **All-SO visible edges** — hinge snapped to edges on wrong faces, floated visually
2. **8px floater check** — masked the bug, blinked due to occlusion boundary jitter
3. **Parent face edges only** — geometrically correct, removed floater check entirely

But angulars still blink. The blinking comes from upstream — `intersect_face_pair` itself produces borderline results. Plane-plane intersection clipped to both face quads is inherently fragile at the boundaries. A tiny rotation shifts the clip region, the segment vanishes for a frame, the angular drops out.

### Attempted simplification: bypass intersections

Tried deriving angulars purely from the child's quat + parent face geometry. Didn't work — the approach was flawed in how it chose hinge points and witness directions. The angular needs to visually connect to the geometry (the crease where child meets parent), not float at an arbitrary face corner.

### What's still broken

All angulars blink. The intersection-based pipeline is the root cause — it's the wrong foundation. The right answer probably lives upstream in the quaternion decomposition question: once we know the angles authoritatively, we can place angulars without depending on fragile geometric intersection.
