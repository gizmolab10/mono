# w2 — Port ws to Svelte 5

**Started:** 2026-02-20
**Status:** Phase 1 — Design Spec (complete)

## Goal

Rewrite ws as w2: a clean Svelte 5 port. Eliminate cruft and ad-hoc logic

- [x] architectural decisions (phase 2)
	- [x] i want option 3 and A and di's css
- [x] phase 1 design spec → [w2/](./w2/)
- [ ] fresh build

## Phases

1. [x] **Design spec** — read every file, document what each subsystem does → [w2/](./w2/)
2. [x] **Architectural decisions** — choose patterns for hierarchy, signals, reactivity
3. [ ] **Fresh build** — new project (w2), built from spec

---

## Codebase Assessment

**Svelte 4** · 170 source files · **~24,400 lines**

### TypeScript (96 files, ~17,000 lines)

| Subsystem | Files | Lines |
|-----------|-------|-------|
| managers | 16 | 4,030 |
| database | 9 | 2,370 |
| tests | 12 | 2,146 |
| utilities | 5 | 1,396 |
| geometry | 10 | 1,303 |
| common | 5 | 1,287 |
| state | 15 | 1,048 |
| runtime | 2 | 1,011 |
| signals | 3 | 752 |
| types | 5 | 618 |
| persistable | 8 | 461 |
| files | 3 | 439 |
| debug | 2 | 157 |

### Svelte (74 files, ~7,350 lines)

| Module | Files | Lines |
|--------|-------|-------|
| mouse | 16 | 1,780 |
| details | 8 | 1,047 |
| widget | 4 | 1,021 |
| main | 7 | 726 |
| draw | 11 | 703 |
| experimental | 11 | 622 |
| controls | 4 | 398 |
| radial | 3 | 388 |
| text | 4 | 269 |
| search | 3 | 231 |
| tree | 3 | 163 |

### Heaviest Files

- `Hierarchy.ts` — 1,753 lines
- `DB_Firebase.ts` — 971
- `Ancestry.ts` — 966
- `Events.ts` — 490
- `Extensions.ts` — 472
- `SVG_Paths.ts` — 464
- `Colors.ts` — 412

### Dependencies

Svelte 4, d3, Firebase, Dexie (IndexedDB), rbush (spatial), gl-matrix, Two.js, typed-signals, rxdb/rxjs. Also React and Framework7 in deps — likely dead weight.

### Estimated Effort

- **Phase 1 (design spec):** ~3–5 deep sessions
- **Phase 2 (arch decisions):** ~2–3 sessions
- **Phase 3 (fresh build):** ~15–25 sessions
- **Total:** ~20–30 working sessions

Biggest variable: how much architecture gets rethought vs just modernized.

---

## Hierarchy Assessment

`Hierarchy.ts` is a **god object** (1,753 lines, single class). It simultaneously serves as:

1. **Entity store** — 22 private dictionaries for Things, Relationships, Ancestries, Predicates, Traits, Tags, Users, Access
2. **Entity lifecycle** — remember/forget/create/extract for every type (CRUD per entity)
3. **Ancestry navigation** — tree traversal, expansion, focus, browsing, relocating
4. **UX orchestration** — keyboard-driven browsing, radial mode logic, visibility decisions
5. **Persistence bridge** — delegates to `db` for Firebase/filesystem/file import/export
6. **File I/O** — JSON, CSV, `.seriously` format import/export
7. **Lost & found** — orphan recovery
8. **Bulk alias management** — cross-database entity stitching

The 14 `static readonly _____SECTION: unique symbol` lines are makeshift section dividers — the code telling you it wants to be split up.

### Hierarchy Options

**Option 1: Entity Store + Services**

Split into a dumb store (the dictionaries, remember/forget) and domain services (navigation, persistence, file I/O, bulk management). The store is just data; services read and write it.

- `HierarchyStore` — entities + lookup + remember/forget
- `NavigationService` — focus, browse, expand, relocate
- `PersistenceService` — DB bridge, dirty tracking, persist_all
- `FileService` — import/export JSON/CSV/seriously
- `BulkService` — cross-database stitching

Pro: Minimal conceptual leap from current code. Each service is testable.
Con: Services still need cross-references. Risk of recreating the god object via a service locator.

**Option 2: Entity-Centric with Graph**

Each entity type owns its own store and CRUD. A separate `Graph` object handles structural operations (ancestry, traversal, navigation). File I/O becomes a standalone utility that reads/writes the stores.

- `ThingStore`, `RelationshipStore`, `AncestryStore`, etc.
- `Graph` — structural operations, traversal, focus/expand
- `FileIO` — import/export, stateless, reads stores
- `BulkBridge` — cross-DB stitching

Pro: Clean separation. Entity stores are trivially testable. Graph is the only complex piece.
Con: More files. Cross-store queries (e.g., "all traits for thing X") need a query layer or explicit joins.

**Option 3: Normalized Reactive Store (ECS-inspired)**

A single normalized store (like a client-side database) with typed tables. Queries are derived/computed. Operations are mutations. The store is the single source of truth; everything else derives from it.

- `Store` — normalized tables for each entity type, indexed by HID
- Derived queries (children of X, ancestries for thing, etc.)
- Mutations replace remember/forget
- Navigation becomes derived state, not imperative methods

Pro: Plays perfectly with Svelte 5 runes (`$state`, `$derived`). Eliminates the imperative `get()` calls. Single source of truth. Testable via snapshot.
Con: Biggest rewrite. Requires rethinking every query as a derivation. The 22 dictionaries become indexes on a normalized store — cleaner, but different.

**Option 4: Hybrid — Option 1 now, evolve toward Option 3**

Start with services split, but design the store interface so it can be swapped for a reactive normalized store later.

Pro: Incremental. Ship sooner.
Con: You'll rewrite the store layer anyway. Two refactors.

---

## Signal System Assessment

Three files, three layers:

1. **`Signals.ts`** (152 lines) — priority-based pub/sub using `typed-signals` library. Emits rebuild/reattach/reposition/alteration/thing signals. Each signal type has a highest priority; on emit, it fires for every priority 0..N sequentially. Components subscribe at a priority level.

2. **`Events.ts`** (490 lines) — DOM event wiring (mouse, touch, keyboard, wheel, resize) + the full keyboard shortcut dispatch table + action handler dispatch table. Also a god object: event binding, input mapping, action dispatch, and disable-state logic all in one class.

3. **`Mouse_Timer.ts`** (110 lines) — autorepeat, double-click, long-click, alteration blink timers. Clean, small, focused. This one's fine.

### Current Reactivity Model — a Hybrid Mess

Four separate reactivity mechanisms competing:

- Svelte 4 `writable`/`derived` stores in UX, Core, Events
- `typed-signals` priority-based pub/sub in Signals
- Manual `get()` calls everywhere to read store values imperatively
- `S_Items.w_item` / `S_Items.w_items` as writable stores inside a collection class
- `g.grand_build()` / `g.grand_sweep()` / `g.layout()` as imperative graph rebuild triggers

### Signal System Options

**Option A: Svelte 5 runes only (drop typed-signals entirely)**

Replace everything with `$state`, `$derived`, and `$effect`. No custom signal bus. Components react to state changes directly. The priority system becomes unnecessary — Svelte's fine-grained reactivity handles ordering.

Pro: One reactivity model. Simpler. Leverages what Svelte 5 is built for. No library dependency.
Con: Loses explicit priority ordering (if that actually matters — it may not). Effects can cascade if not careful.

**Option B: Svelte 5 runes + lightweight event bus for cross-cutting concerns**

Runes for all state. A small custom event bus (not typed-signals, just a 20-line emitter) for the few things that are genuinely "events" — alteration blink, window resize, orientation change.

Pro: Clean separation: state is reactive, events are events. Minimal custom code.
Con: Two mechanisms, but intentionally scoped.

**Option C: Keep typed-signals, modernize everything else**

Upgrade stores to runes but keep the priority signal system for component coordination.

Pro: Least change to signal architecture.
Con: Keeps a dependency that Svelte 5's reactivity could replace. The priority system adds complexity that may not earn its keep.

---

## Recommendation

**Option 3 + Option A** is the cleanest target for a from-scratch port. Most work, but since we're starting fresh in w2, we'd arrive at a codebase that's half the size and fully idiomatic Svelte 5.

**Option 1 + Option B** is the pragmatic middle ground for shipping faster.

---

## Draw Layer: Box, Separator, Fillet

ws builds these from **SVG + absolute positioning** (5 components, 375 lines in `ws/src/lib/svelte/draw/`):

- `Box.svelte` (72 lines) — nested divs + Separator components on all four sides, absolute positioning with Point calculations
- `Separator.svelte` (133 lines) — background-color divs for lines + Fillets SVG overlays at ends, thin divider option, optional title
- `Fillets.svelte` (44 lines) — pure SVG quarter-circle arcs via `svgPaths.fillets()`
- `Circle.svelte` (25 lines) + `Transparent_Circle.svelte` (37 lines) — pure CSS `border-radius: 50%`

The overlap rule (separators extend `thickness/2` past endpoints to center fillets on intersections) adds geometric bookkeeping throughout. Every separator needs Point math for placement. Fillets are SVG paths computed from polar coordinates.

### di's CSS-only approach

di achieves the same visual result with **zero SVG, zero custom components** (`di/src/lib/svelte/main/Main.svelte`, 116 lines total):

```svelte
<!-- The separator color IS the background -->
<div class='panel'
    style:background-color={$w_separator_color}
    style:padding='{gap}px'>
    <div class='region controls'>...</div>
    <div class='main'>
        <div class='region details'>...</div>
        <div class='region graph'>...</div>
    </div>
</div>
```

```css
.main   { display: flex; gap: var(--gap); }
.region { border-radius: var(--radius); overflow: hidden; }
```

The trick: the panel background *is* the separator color. Regions are rounded rectangles with `border-radius`. The `gap` between flex children reveals the panel background — which looks like separators. Fillets are just `border-radius` on the region divs. No SVG, no overlap math, no Point calculations, no five-component abstraction.

**Result:** 375 lines of SVG/geometry → ~10 lines of CSS. Same visual. Simpler, faster, maintainable.

### Decision for w2

Use the di CSS approach. Drop Box, Separator, Fillets components entirely. Layout via flex + gap + border-radius.

---

## Next Action

Begin Phase 3: fresh build. Start with the normalized store layer (`$state` tables for Thing, Relationship, Predicate, etc.), then Graph/navigation, then UI shell.
